[
    {
        "readme": "# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```",
        "current_file_path": "cve202344487.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```\n\n---\nFunction Complement\n---\ndef get_source_ips(proxies):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    try:\n        response = requests.get(\"http://ifconfig.me\", timeout=5, proxies=proxies)\n        external_ip = response.text.strip()\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        s.settimeout(2)\n        try:\n            s.connect((\"8.8.8.8\", 1))\n            internal_ip = s.getsockname()[0]\n        except socket.timeout:\n            internal_ip = \"127.0.0.1\"\n        except Exception as e:\n            internal_ip = \"127.0.0.1\"\n        finally:\n            s.close()\n        return internal_ip, external_ip\n    except requests.exceptions.Timeout:\n        print(\"External IP request timed out.\")\n        return None, None\n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None, None\n```"
    },
    {
        "readme": "# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```",
        "current_file_path": "cve202344487.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```\n\n---\nFunction Complement\n---\ndef check_http2_support(url, proxies):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    try:\n        local_proxies = {}\n        if proxies:\n            local_proxies = {\"http://\": proxies[\"http\"], \"https://\": proxies[\"https\"]}\n        client_options = {\"http2\": True, \"verify\": False}\n        if local_proxies:\n            client_options[\"proxies\"] = local_proxies\n        with httpx.Client(**client_options) as client:\n            response = client.get(url)\n        if response.http_version == \"HTTP/2\":\n            return 1, \"\"\n        else:\n            return 0, f\"{response.http_version}\"\n    except Exception as e:\n        return -1, f\"check_http2_support - {e}\"\n```"
    },
    {
        "readme": "# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```",
        "current_file_path": "cve202344487.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    pass\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```\n\n---\nFunction Complement\n---\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    try:\n        ssl_context = ssl.create_default_context()\n        ssl_context.check_hostname = False\n        ssl_context.verify_mode = ssl.CERT_NONE\n        if proxy and proxy != \"\":\n            proxy_parts = urlparse(proxy)\n            if port == 443:\n                conn = HTTPSConnection(\n                    proxy_parts.hostname,\n                    proxy_parts.port,\n                    timeout=timeout,\n                    context=ssl_context,\n                )\n                conn.set_tunnel(host, port)\n            else:\n                conn = HTTPConnection(\n                    proxy_parts.hostname, proxy_parts.port, timeout=timeout\n                )\n                conn.set_tunnel(host, port)\n        elif port == 443:\n            conn = HTTPSConnection(host, port, timeout=timeout, context=ssl_context)\n        else:\n            conn = HTTPConnection(host, port, timeout=timeout)\n        conn.connect()\n        config = H2Configuration(client_side=True)\n        h2_conn = H2Connection(config=config)\n        h2_conn.initiate_connection()\n        conn.send(h2_conn.data_to_send())\n        headers = [\n            (\":method\", \"GET\"),\n            (\":authority\", host),\n            (\":scheme\", \"https\"),\n            (\":path\", uri_path),\n        ]\n        h2_conn.send_headers(stream_id, headers)\n        conn.send(h2_conn.data_to_send())\n        while True:\n            data = conn.sock.recv(65535)\n            if not data:\n                break\n            events = h2_conn.receive_data(data)\n            has_sent = False\n            for event in events:\n                if hasattr(event, \"stream_id\"):\n                    if event.stream_id == stream_id:\n                        h2_conn.reset_stream(event.stream_id)\n                        conn.send(h2_conn.data_to_send())\n                        has_sent = True\n                        break\n            if has_sent:\n                return 1, \"\"\n            else:\n                available_id = h2_conn.get_next_available_stream_id()\n                if available_id == 0:\n                    h2_conn.reset_stream(1)\n                    conn.send(h2_conn.data_to_send())\n                    return (\n                        0,\n                        \"Able to send RST_STREAM to stream 1 but could not find any available stream ids\",\n                    )\n                else:\n                    h2_conn.reset_stream(available_id)\n                    conn.send(h2_conn.data_to_send())\n                    return 1, \"\"\n        conn.close()\n        return 0, \"No response\"\n    except Exception as e:\n        return -1, f\"send_rst_stream_h2 - {e}\"\n```"
    },
    {
        "readme": "# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```",
        "current_file_path": "cve202344487.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# CVE-2023-44487\nBasic vulnerability scanning to see if web servers may be vulnerable to CVE-2023-44487\n\nThis tool checks to see if a website is vulnerable to CVE-2023-44487 completely non-invasively.\n\n1. The tool checks if a web server accepts HTTP/2 requests without downgrading them\n2. If the web server accepts and does not downgrade HTTP/2 requests the tool attempts to open a connection stream and subsequently reset it\n3. If the web server accepts the creation and resetting of a connection stream then the server is definitely vulnerable, if it only accepts HTTP/2 requests but the stream connection fails it may be vulnerable if the server-side capabilities are enabled.\n\nTo run,\n\n    $ python3 -m pip install -r requirements.txt\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv\n\nYou can also specify an HTTP proxy to proxy all the requests through with the `--proxy` flag\n\n    $ python3 cve202344487.py -i input_urls.txt -o output_results.csv --proxy http://proxysite.com:1234\n\nThe script outputs a CSV file with the following columns\n\n- Timestamp: a timestamp of the request\n- Source Internal IP: The internal IP address of the host sending the HTTP requests\n- Source External IP: The external IP address of the host sending the HTTP requests\n- URL: The URL being scanned\n- Vulnerability Status: \"VULNERABLE\"/\"LIKELY\"/\"POSSIBLE\"/\"SAFE\"/\"ERROR\"\n- Error/Downgrade Version: The error or the version the HTTP server downgrades the request to\n\n*Note: \"Vulnerable\" in this context means that it is confirmed that an attacker can reset the a stream connection without issue, it does not take into account implementation-specific or volume-based detections*\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cve202344487.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `cve202344487.py`.\n\n```python\nimport argparse\nimport csv\nimport socket\nimport ssl\nimport sys\nfrom datetime import datetime\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nimport httpx\nimport requests\nfrom h2.config import H2Configuration\nfrom h2.connection import H2Connection\n\n\ndef get_source_ips(proxies):\n    \"\"\"\n    Retrieve the internal and external IP addresses of the machine.\n\n    Accepts:\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (internal_ip, external_ip)\n    \"\"\"\n    pass\n\n\ndef check_http2_support(url, proxies):\n    \"\"\"\n    Check if the given URL supports HTTP/2.\n\n    Parameters:\n        url (str): The URL to check.\n        proxies (dict): A dictionary of proxies to use for the requests.\n\n    Returns:\n        tuple: (status, error/version)\n        status: 1 if HTTP/2 is supported, 0 otherwise, -1 on error.\n        error/version: Error message or HTTP version if not HTTP/2.\n    \"\"\"\n    pass\n\n\ndef send_rst_stream_h2(host, port, stream_id, uri_path=\"/\", timeout=5, proxy=None):\n    \"\"\"\n    Send an RST_STREAM frame to the given host and port.\n\n    Parameters:\n        host (str): The hostname.\n        port (int): The port number.\n        stream_id (int): The stream ID to reset.\n        uri_path (str): The URI path for the GET request.\n        timeout (int): The timeout in seconds for the socket connection.\n        proxy (str): The proxy URL, if any.\n\n    Returns:\n        tuple: (status, message)\n        status: 1 if successful, 0 if no response, -1 otherwise.\n        message: Additional information or error message.\n    \"\"\"\n    pass\n\n\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\", default=\"/dev/stdout\")\n    parser.add_argument(\"--proxy\", help=\"HTTP/HTTPS proxy URL\", default=None)\n    parser.add_argument(\"-v\", \"--verbose\", action=\"store_true\")\n    args = parser.parse_args()\n    proxies = {}\n    if args.proxy:\n        proxies = {\"http\": args.proxy, \"https\": args.proxy}\n    internal_ip, external_ip = get_source_ips(proxies)\n    with open(args.input) as infile, open(args.output, \"w\", newline=\"\") as outfile:\n        csv_writer = csv.writer(outfile)\n        csv_writer.writerow(\n            [\n                \"Timestamp\",\n                \"Source Internal IP\",\n                \"Source External IP\",\n                \"URL\",\n                \"Vulnerability Status\",\n                \"Error/Downgrade Version\",\n            ]\n        )\n        for line in infile:\n            addr = line.strip()\n            if addr != \"\":\n                now = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                if args.verbose:\n                    print(f\"Checking {addr}...\", file=sys.stderr)\n                http2support, err = check_http2_support(addr, proxies)\n                hostname, port, uri = extract_hostname_port_uri(addr)\n                if http2support == 1:\n                    resp, err2 = send_rst_stream_h2(\n                        hostname, port, 1, uri, proxy=args.proxy\n                    )\n                    if resp == 1:\n                        csv_writer.writerow(\n                            [now, internal_ip, external_ip, addr, \"VULNERABLE\", \"\"]\n                        )\n                    elif resp == -1:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"POSSIBLE\",\n                                f\"Failed to send RST_STREAM: {err2}\",\n                            ]\n                        )\n                    elif resp == 0:\n                        csv_writer.writerow(\n                            [\n                                now,\n                                internal_ip,\n                                external_ip,\n                                addr,\n                                \"LIKELY\",\n                                \"Got empty response to RST_STREAM request\",\n                            ]\n                        )\n                elif http2support == 0:\n                    csv_writer.writerow(\n                        [\n                            now,\n                            internal_ip,\n                            external_ip,\n                            addr,\n                            \"SAFE\",\n                            f\"Downgraded to {err}\",\n                        ]\n                    )\n                else:\n                    csv_writer.writerow(\n                        [now, internal_ip, external_ip, addr, \"ERROR\", err]\n                    )\n```\n\n---\nFunction Complement\n---\ndef extract_hostname_port_uri(url):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_hostname_port_uri(url):\n    \"\"\"\n    Extract the hostname, port, and URI from a URL.\n\n    Parameters:\n        url (str): The URL to extract from.\n\n    Returns:\n        tuple: (hostname, port, uri)\n    \"\"\"\n    try:\n        parsed_url = urlparse(url)\n        hostname = parsed_url.hostname\n        port = parsed_url.port\n        scheme = parsed_url.scheme\n        uri = parsed_url.path\n        if uri == \"\":\n            uri = \"/\"\n        if not hostname:\n            return -1, -1, \"\"\n        if port:\n            return hostname, port, uri\n        if scheme == \"http\":\n            return hostname, 80, uri\n        if scheme == \"https\":\n            return hostname, 443, uri\n        return hostname, (80, 443), uri\n    except Exception as e:\n        return -1, -1, \"\"\n```"
    }
]