[
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        \"\"\"TODO\"\"\"\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        \"\"\"TODO\"\"\"\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef __init__(self, tone):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self, tone):\n    assert tone in TONES\n    self.tone = tone\n    self.scale = [\n        TONES[(TONES.index(self.tone) + diff) % len(TONES)] for diff in self.base_diff\n    ]\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        \"\"\"TODO\"\"\"\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        \"\"\"TODO\"\"\"\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef normalize_to_freq(cls, tone_or_freq):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef normalize_to_freq(cls, tone_or_freq):\n    if isinstance(tone_or_freq, (float, int)):\n        return tone_or_freq\n    return cls.tone_freq_map[tone_or_freq]\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        \"\"\"TODO\"\"\"\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        \"\"\"TODO\"\"\"\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef get_tone_and_freq(self, min_freq=0, max_freq=4186):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_tone_and_freq(self, min_freq=0, max_freq=4186):\n    min_freq = self.normalize_to_freq(min_freq)\n    max_freq = self.normalize_to_freq(max_freq)\n    ret = []\n    for i in range(0, 8):\n        for base_tone in self.scale:\n            tone = f\"{base_tone}{i}\"\n            freq = self.tone_freq_map[tone]\n            if min_freq <= freq <= max_freq:\n                ret.append((tone, freq))\n    ret.sort()\n    return ret\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    \"\"\"TODO\"\"\"\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    \"\"\"TODO\"\"\"\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef draw_standard(tone, min_freq, max_freq):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef draw_standard(tone, min_freq, max_freq):\n    labels = []\n    for tone, f in Tonality(tone).get_tone_and_freq(min_freq, max_freq):\n        plt.axline((0, f), (1, f), lw=2)\n        label = plt.text(1.01, f, tone, ha=\"left\", va=\"bottom\", fontsize=18)\n        label.set_visible(False)\n        labels.append(label)\n    return labels\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    \"\"\"TODO\"\"\"\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    \"\"\"TODO\"\"\"\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    m = magic.magic()\n    progress_bar.update(1)\n    pitch_values = pitch.selected_array[\"frequency\"]\n    pitch_values[pitch_values == 0] = np.nan\n    curr_time = frame / FRAME_PER_SEC\n    time_start = curr_time - 2.5\n    time_end = curr_time + 2.5\n    pitch_in_range = [\n        p for p in zip(pitch.xs(), pitch_values) if time_start <= p[0] <= time_end\n    ]\n    pitch_xs = [p[0] for p in pitch_in_range]\n    pitch_vals = [p[1] for p in pitch_in_range]\n    assert 0 not in pitch_vals\n    ln.set_data(pitch_xs, pitch_vals)\n    mid_ln.set_data([[curr_time, curr_time], [0, 1]])\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", category=RuntimeWarning)\n        avr_pitch = np.nanmean(\n            pitch_vals[len(pitch_vals) // 3 : len(pitch_vals) * 2 // 3]\n        )\n    if not np.isnan(avr_pitch):\n        pitch_low, pitch_high = avr_pitch * m[2233] ** (\n            -m[41] / m[1823]\n        ), avr_pitch * m[72] ** (m[1795] / m[1823])\n        getattr(plt, \"\".join(chr(m[i]) for i in [490, 403, 343, 367]))(\n            pitch_low, pitch_high\n        )\n        for label in labels:\n            _, y = label.get_position()\n            if pitch_low <= y <= pitch_high:\n                label.set_visible(True)\n            else:\n                label.set_visible(False)\n    for label in labels:\n        _, y = label.get_position()\n        label.set_position((time_start + 0.01, y))\n    getattr(plt, \"\".join(chr(m[i]) for i in [190, 275, 135, 193]))(time_start, time_end)\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    \"\"\"TODO\"\"\"\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    \"\"\"TODO\"\"\"\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    pass\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    snd = parselmouth.Sound(path)\n    pitch = snd.to_pitch_ac(pitch_floor=min_freq, pitch_ceiling=max_freq)\n    plt.rcParams.update({\"font.size\": 15})\n    fig = plt.figure(figsize=(19.2, 10.8), layout=\"tight\")\n    labels = draw_standard(tone, min_freq, max_freq)\n    plt.xlim([snd.xmin, snd.xmax])\n    (ln,) = plt.plot([0], [0], \".\", markersize=10, color=\"orange\")\n    mid_ln = plt.axvline(0, color=\"red\")\n    plt.gca().axes.get_yaxis().set_visible(False)\n    plt.yscale(\"log\")\n    plt.ylabel(\"fundamental frequency [Hz]\")\n    render_time = snd.xmax\n    print(\"Generating pitch video\")\n    with tqdm.tqdm(\n        total=int(render_time * FRAME_PER_SEC), unit=\"frame\", ncols=100\n    ) as progress_bar:\n        ani = animation.FuncAnimation(\n            fig,\n            partial(\n                animate,\n                pitch=pitch,\n                ln=ln,\n                mid_ln=mid_ln,\n                progress_bar=progress_bar,\n                labels=labels,\n            ),\n            frames=range(int(render_time * FRAME_PER_SEC)),\n        )\n        FFWriter = animation.FFMpegWriter(fps=FRAME_PER_SEC)\n        ani.save(output, writer=FFWriter)\n    plt.close()\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [
            "magic.py"
        ],
        "relevant_file_sketches": "---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```",
        "current_file_path": "gen_pitch.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nRelevant File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nCurrent File Sketch/2\n---\nHere is the file sketch of `gen_pitch.py`.\n\n```python\nimport argparse\nimport os\nimport shutil\nimport subprocess\nimport tempfile\nimport warnings\nfrom functools import partial\nimport magic\nimport matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport parselmouth\nimport tqdm\n\nFRAME_PER_SEC = 15\nTONES = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"]\n\n\nclass Tonality:\n    base_diff = [0, 2, 4, 5, 7, 9, 11]\n    tone_freq_map = {\n        f\"{t}{i}\": (2 ** (TONES.index(t) / 12 + i) * 16.3516)\n        for t in TONES\n        for i in range(0, 8)\n    }\n\n    def __init__(self, tone):\n        pass\n\n    @classmethod\n    def normalize_to_freq(cls, tone_or_freq):\n        pass\n\n    def get_tone_and_freq(self, min_freq=0, max_freq=4186):\n        pass\n\n\ndef draw_standard(tone, min_freq, max_freq):\n    pass\n\n\ndef animate(frame, pitch, ln, mid_ln, progress_bar, labels):\n    pass\n\n\ndef generate_pitch_video(path, output, tone, min_freq, max_freq):\n    pass\n\n\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    magic.magic()\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"--audio\", type=str, help=\"path to the input audio file\", required=True\n    )\n    parser.add_argument(\"video\", type=str, help=\"path to the input video file\")\n    parser.add_argument(\"--output\", \"-o\", type=str, required=False)\n    parser.add_argument(\"--tone\", \"-t\", type=str, required=True)\n    parser.add_argument(\"--ffmpeg\", type=str)\n    parser.add_argument(\"--pitch_width\", type=int, default=None)\n    parser.add_argument(\n        \"--pitch_position\",\n        type=str,\n        default=\"top_right\",\n        choices=[\"top_right\", \"top_left\", \"bottom_right\", \"bottom_left\"],\n    )\n    parser.add_argument(\"--min_pitch\", type=str, default=\"D2\")\n    parser.add_argument(\"--max_pitch\", type=str, default=\"G5\")\n    options = parser.parse_args()\n    if not os.path.exists(options.audio):\n        print(f\"Audio file {options.audio} does not exist\")\n        exit(1)\n    if not os.path.exists(options.video):\n        print(f\"Video file {options.video} does not exist\")\n        exit(1)\n    if options.ffmpeg is None:\n        options.ffmpeg = shutil.which(\"ffmpeg\")\n    if options.ffmpeg is None or not os.path.exists(options.ffmpeg):\n        print(\"Unable to locate ffmpeg, use --ffmpeg to specify the path to ffmpeg\")\n        exit(1)\n    if options.tone not in TONES:\n        print(f\"Invalid tone {options.tone}\")\n        exit(1)\n    if options.output is None:\n        options.output = \".\".join(options.video.split(\".\")[:-1]) + \"_with_pitch.mp4\"\n    try:\n        min_freq = Tonality.normalize_to_freq(options.min_pitch)\n        max_freq = Tonality.normalize_to_freq(options.max_pitch)\n    except Exception:\n        print(f\"Invalid min/max pitch {options.min_pitch}/{options.max_pitch}\")\n        exit(1)\n    plt.rcParams[\"animation.ffmpeg_path\"] = options.ffmpeg\n    with tempfile.TemporaryDirectory() as tmpdir:\n        pitch_video_path = os.path.join(tmpdir, \"pitch.mp4\")\n        generate_pitch_video(\n            options.audio, pitch_video_path, options.tone, min_freq, max_freq\n        )\n        combine_video(\n            options.ffmpeg,\n            options.video,\n            pitch_video_path,\n            options.output,\n            options.pitch_width,\n            options.pitch_position,\n        )\n```\n\n---\nFunction Complement\n---\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef combine_video(\n    ffmpeg, video_path, pitch_video_path, output_path, pitch_width, pitch_position\n):\n    print(\"Combining video\")\n    if pitch_width is None:\n        process = subprocess.run(\n            [\n                \"ffprobe\",\n                \"-v\",\n                \"error\",\n                \"-select_streams\",\n                \"v:0\",\n                \"-show_entries\",\n                \"stream=width,height\",\n                \"-of\",\n                \"csv=s=x:p=0\",\n                video_path,\n            ],\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        width, _ = process.stdout.decode().split(\"x\")\n        pitch_width = int(width) // 2\n    if pitch_position == \"top_right\":\n        overlay_param = f\"W-w-10:10\"\n    elif pitch_position == \"top_left\":\n        overlay_param = f\"10:10\"\n    elif pitch_position == \"bottom_right\":\n        overlay_param = f\"W-w-10:H-h-10\"\n    elif pitch_position == \"bottom_left\":\n        overlay_param = f\"10:H-h-10\"\n    else:\n        raise ValueError(f\"Invalid pitch position {pitch_position}\")\n    with magic.magic3() as m:\n        print(f\"Writing to {os.path.abspath(output_path)}\")\n        subprocess.run(\n            [\n                ffmpeg,\n                \"-loglevel\",\n                \"error\",\n                \"-stats\",\n                \"-i\",\n                video_path,\n                \"-i\",\n                pitch_video_path,\n                *m,\n                f\"[1:v]scale={pitch_width}:-1 [scaled_ol]; [2:v]scale={pitch_width}:-1 [scaled_wm]; [0:v][scaled_ol]overlay={overlay_param}[temp]; [temp][scaled_wm]overlay={overlay_param}[outv]\",\n                \"-map\",\n                \"[outv]\",\n                \"-map\",\n                \"0:a\",\n                output_path,\n            ],\n            check=True,\n        )\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    \"\"\"TODO\"\"\"\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```",
        "current_file_path": "magic.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    \"\"\"TODO\"\"\"\n\n\n@c.contextmanager\ndef magic3():\n    pass\n```\n\n---\nFunction Complement\n---\ndef magic():\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef magic():\n    global _m\n    if _m is None:\n        with open(\"./magic\", \"rb\") as f:\n            _m = f.read()\n            if h.md5(_m[16:]).digest() != _m[:16]:\n                exit(0)\n    return _m\n```"
    },
    {
        "readme": "# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    \"\"\"TODO\"\"\"\n```",
        "current_file_path": "magic.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# Pitch Visualizer\n\nThis is a small Python script that visualizes the pitch of a pure vocal audio, merges it with the original video, and ultimately generates a video with dynamic pitch annotations.\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 gen_pitch.py # import magic;\n\u251c\u2500\u2500 magic.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `magic.py`.\n\n```python\nimport contextlib as c\nimport hashlib as h\nimport os as o\nimport tempfile as t\n\n_m = None\n\n\ndef magic():\n    pass\n\n\n@c.contextmanager\ndef magic3():\n    \"\"\"TODO\"\"\"\n```\n\n---\nFunction Complement\n---\ndef magic3():\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef magic3():\n    with t.TemporaryDirectory() as _t:\n        with open(o.path.join(_t, \"m.png\"), \"wb\") as f:\n            f.write(magic()[16:])\n        yield \"-i\", o.path.join(_t, \"m.png\"), \"-filter_complex\"\n```"
    }
]