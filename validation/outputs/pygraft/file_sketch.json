[
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "setup.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\nsetup.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nfrom setuptools import find_packages, setup\n\nwith open(\"README.md\", \"r\", encoding=\"utf8\") as fh:\n    long_description = fh.read()\nsetup(\n    name=\"pygraft\",\n    version=\"0.0.3\",\n    packages=find_packages(exclude=\"docs\"),\n    include_package_data=True,\n    zip_safe=False,\n    package_data={\n        \"pygraft\": [\n            \"examples/template.json\",\n            \"examples/template.yml\",\n            \"property_checks/combinations.json\",\n            \"property_checks/compat_p1p2_inverseof.txt\",\n        ]\n    },\n    entry_points={\"console_scripts\": [\"pygraft = pygraft.main:main\"]},\n    license=\"MIT\",\n    description=\"PyGraft: Configurable Generation of Schemas and Knowledge Graphs at Your Fingertips\",\n    author=\"Nicolas Hubert\",\n    author_email=\"nicolas.hubert@univ-lorraine.fr\",\n    url=\"https://github.com/nicolas-hbt\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    keywords=[\n        \"Knowledge Graph\",\n        \"Ontology\",\n        \"Schema\",\n        \"Semantic Web\",\n        \"Synthetic Data Generator\",\n    ],\n    install_requires=[\n        \"numpy>=1.24.0\",\n        \"matplotlib>=3.7.0\",\n        \"Owlready2>=0.41\",\n        \"rdflib>=6.2.0\",\n        \"pyyaml\",\n        \"tabulate\",\n        \"art\",\n        \"tqdm\",\n    ],\n    python_requires=\">=3.7\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Science/Research\",\n        \"Topic :: Software Development :: Build Tools\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Programming Language :: Python :: 3 :: Only\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n        \"Topic :: Scientific/Engineering :: Information Analysis\",\n    ],\n)\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "docs/source/conf.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\ndocs/source/conf.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nfrom datetime import date\nimport sphinx_rtd_theme\n\nproject = \"PyGraft\"\ncopyright = f\"2023-{date.today().year}, Nicolas Hubert\"\nauthor = \"Nicolas Hubert\"\nrelease = \"0.1.0\"\nextensions = [\n    \"sphinx.ext.duration\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.autodoc\",\n    \"sphinxcontrib.bibtex\",\n    \"sphinxemoji.sphinxemoji\",\n    \"sphinx.ext.autosummary\",\n    \"sphinx.ext.mathjax\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.intersphinx\",\n]\nbibtex_bibfiles = [\"bibliography.bib\"]\nsphinxemoji_style = \"twemoji\"\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"numpy\": (\"https://numpy.org/doc/stable\", None),\n    \"sphinx\": (\"https://www.sphinx-doc.org/en/master/\", None),\n}\nautosummary_generate = True\nsource_suffix = [\".rst\", \".md\"]\nmaster_doc = \"index\"\nlanguage = \"en\"\npygments_style = \"sphinx\"\nintersphinx_disabled_domains = [\"std\"]\ntemplates_path = [\"_templates\"]\nproject = \"PyGraft\"\ncopyright = \"PyGraft is licensed under the MIT License\"\nauthor = \"Nicolas Hubert\"\nhtml_theme = \"sphinx_rtd_theme\"\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\nhtml_theme_options = {\"style_nav_header_background\": \"#FFFFFF\"}\nhtml_css_files = [\"style.css\"]\nhtml_logo = \"logo.svg\"\nhtmlhelp_basename = \"PyGraftdoc\"\nepub_show_urls = \"footnote\"\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/__init__.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/__init__.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nfrom .pygraft import (\n    create_json_template,\n    create_template,\n    create_yaml_template,\n    generate,\n    generate_kg,\n    generate_schema,\n)\n\n__all__ = [\n    \"create_template\",\n    \"create_json_template\",\n    \"create_yaml_template\",\n    \"generate_schema\",\n    \"generate_kg\",\n    \"generate\",\n]\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/class_generator.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/class_generator.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport copy\nimport random\nfrom collections import defaultdict\nimport numpy as np\nfrom pygraft.utils_schema import *\nfrom tabulate import tabulate\n\n\nclass ClassGenerator:\n    def __init__(self, **kwargs):\n        pass\n\n    def init_params(self, **kwargs):\n        \"\"\"\n        Initializes the parameters for the class generator.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            kwargs (dict): The keyword arguments.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def init_class_structures(self):\n        \"\"\"\n        Initializes the class structures for the class generator.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_class_schema(self):\n        \"\"\"\n        Generates a class schema based on the given parameters.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            class_info (dict): A dictionary containing various information about the class.\n        \"\"\"\n        pass\n\n    def assemble_class_info(self):\n        \"\"\"\n        Assembles and returns information about the current class schema.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            class_info (dict): A dictionary containing various information about the class.\n        \"\"\"\n        pass\n\n    def generate_classes(self):\n        \"\"\"\n        Generates the classes for the given self instance based on the\n        given number of classes.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_class_hierarchy(self):\n        \"\"\"\n        Generate the class hierarchy for the given self instance.\n        This function creates a hierarchical structure of classes based on the\n        existing classes in the self instance. It assigns each class to a layer\n        and establishes the parent-child relationships between them.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def smart_placing(self, c, current_avg_depth, current_inheritance_ratio):\n        \"\"\"\n        Determines the appropriate action to take based on the current average depth\n        and current inheritance ratio.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): A given class.\n            current_avg_depth (float): The current average depth.\n            current_inheritance_ratio (float): The current inheritance ratio.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def noisy_placing(self, c, current_avg_depth, current_inheritance_ratio):\n        \"\"\"\n        Adds noise to the class hierarchy tree to create more diverse shapes.\n        This function adds randomness to the placement of classes in the hierarchy tree.\n        Without this optional noise, trees tend to be vertical with only a few parents having most children.\n        By putting more weight on the intermediate layers, which tend to be underpopulated otherwise,\n        the hierarchy becomes more realistic.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be placed in the hierarchy tree.\n            current_avg_depth (float): The current average depth of the hierarchy tree.\n            current_inheritance_ratio (float): The current inheritance ratio of the hierarchy tree.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_deep_leaf_realistic(self, c):\n        \"\"\"\n        Create a child to an already existing parent which is deep in the class hierarchy.\n\n        => |S| += 1; |C| += 1; |L| += 1\n        => Inheritance ratio increases.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be placed.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_deep_leaf_deterministic(self, c):\n        \"\"\"\n        Creates a child to an already existing parent which is deep in the class hierarchy.\n\n        => |S| += 1; |C| += 1; |L| += 1\n        => Inheritance ratio increases.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be placed.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_deep_child_realistic(self, c):\n        \"\"\"\n        Creates a child to a leaf which is deep in the class hierarchy.\n\n        => |S| += 1; |C| += 1; |L| = |L| (unchanged)\n        => Inheritance ratio decreases.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be placed.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_deep_child_deterministic(self, c):\n        \"\"\"\n        Creates a child to a leaf which is deep in the class hierarchy.\n\n        => |S| += 1; |C| += 1; |L| = |L| (unchanged)\n        => Inheritance ratio decreases.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be placed.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_shallow_leaf(self, c):\n        \"\"\"\n        Creates a shallow leaf by adding a new class to the class hierarchy.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The class to be added as a shallow leaf.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def create_shallow_leaf_root(self, c):\n        \"\"\"\n        Creates a leaf which is placed just under the root of the class hierarchy.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            c (str): The name of the class.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_class_disjointness(self):\n        \"\"\"\n        Generates class disjointness by randomly selecting two classes and making them incompatible.\n        Updates the class mappings and extend the incompatibilities to subclasses.\n        Calculates the current class disjointness and stops when average disjointness threshold is reached.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extend_incompatibilities(self, class_A, class_B):\n        \"\"\"\n        Extends the incompatibilities between two classes.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n            class_A (str): The first class.\n            class_B (str): The second class.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def link_child2parent(self, child, parent, layer):\n        pass\n\n    def print_schema(self):\n        \"\"\"\n        Prints the generated class schema.\n\n        Args:\n            self (object): The instance of the ClassGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/kg_generator.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/kg_generator.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport copy\nimport itertools\nimport json\nimport time\nfrom collections import Counter\nimport numpy as np\nfrom owlready2 import *\nfrom pygraft.utils import reasoner\nfrom pygraft.utils_kg import *\nfrom rdflib import OWL, RDF\nfrom rdflib import Graph as RDFGraph\nfrom rdflib import Namespace, URIRef\nfrom tqdm.auto import tqdm\n\n\nclass InstanceGenerator:\n    def __init__(self, **kwargs):\n        pass\n\n    def init_params(self, **kwargs):\n        \"\"\"\n        Initializes general KG information with user-specified parameters.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            kwargs (dict): Dictionary of parameter names and values.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def init_utils(self, **kwargs):\n        \"\"\"\n        Initializes auxiliary information.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            kwargs (dict): Dictionary of parameter names and values.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def load_schema_info(self):\n        \"\"\"\n        Loads schema information from class_info and relation_info json files.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def assemble_instance_info(self):\n        \"\"\"\n        Assembles the KG information and returns a dictionary\n        containing statistics and user parameters.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            kg_info (dict): A dictionary containing information about the KG.\n        \"\"\"\n        pass\n\n    def write_kg(self):\n        \"\"\"\n        Writes the KG to a file.\n        Initializes a new RDFGraph object and parses the schema.\n        Each triple in the KG is added to the full graph.\n        The full graph is then serialized to a file and checked for consistency.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_kg(self):\n        pass\n\n    def assign_most_specific(self):\n        \"\"\"\n        Assigns the most specific class to each entity based on the hierarchy depth.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def complete_typing(self):\n        \"\"\"\n        Completes the typing for the current entity (if multityping is enabled).\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def check_multityping(self):\n        \"\"\"\n        Checks the multityping of entities and updates the badly typed entities.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extend_superclasses(self):\n        \"\"\"\n        Extends the superclasses of entities.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def calculate_avg_multityping(self):\n        \"\"\"\n        Calculates the average value of the multityping in the KG.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            float: The average value of multityping.\n        \"\"\"\n        pass\n\n    def find_compatible_classes(self, class_list):\n        \"\"\"\n        Finds the classes that are compatible with the given class list.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            class_list (list): A list of classes.\n\n        Returns:\n            set: A set of compatible classes.\n        \"\"\"\n        pass\n\n    def pipeline(self):\n        \"\"\"\n        Pipeline for processing entities and subsequently generating triples.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Return:\n            None\n        \"\"\"\n        pass\n\n    def distribute_relations(self):\n        \"\"\"\n        Distributes relations based on the number of triples and the relation balance ratio.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Return:\n            None\n\n        \"\"\"\n        pass\n\n    def generate_triples(self):\n        \"\"\"\n        Generates triples for the KG.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_one_triple(self, r):\n        \"\"\"\n        Generates a single triple based on the given relation.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            r (str): The relation for which to generate the triple.\n\n        Returns:\n            tuple: A tuple containing the head entity, relation, and tail entity of the generated triple.\n        \"\"\"\n        pass\n\n    def check_consistency(self, triple):\n        \"\"\"\n        Checks the consistency of a triple before adding it to the KG.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            triple (tuple): A tuple representing a candidate triple (h, r, t).\n\n        Returns:\n            bool: True if the triple is consistent, False otherwise.\n        \"\"\"\n        pass\n\n    def check_inverseof_asymmetry(self):\n        \"\"\"\n        Checks if the inverse-of-asymmetry condition holds for the given relations.\n\n        This method checks if the inverse-of-asymmetry condition holds for each pair of relations (R1, R2)\n        in the rel2inverse dictionary. The inverse-of-asymmetry condition states that if R1 is the inverse of R2,\n        and either R1 or R2 is asymmetric, then the same (h, t) pair cannot be observed with both R1 and R2.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def check_dom_range(self):\n        \"\"\"\n        Checks the domain and range of triples in the KG and removes inconsistent triples.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_rel2inverse(self):\n        \"\"\"\n        Generates a dictionary containing pairs of inverse relations.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            rel2inverse (dict): A dictionary containing the inverse of the relation.\n        \"\"\"\n        pass\n\n    def check_asymmetries(self):\n        \"\"\"\n        Checks for asymmetries in the KG.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def check_class_disjointness(self, ent, expected_class):\n        \"\"\"\n        Checks for class disjointness (owl:disjointWith) between domain/range of a relation\n        and the classes to which belong the randomly sampled entity.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n            ent (str): The entity to check.\n            expected_class (str): The expected class as domain or range of a relation.\n\n        Returns:\n            bool: True if the entity classes and expected class are disjoint, False otherwise.\n        \"\"\"\n        pass\n\n    def oversample_triples_inference(self):\n        \"\"\"\n        Infers new triples to be added to the KG based on logical deductions.\n        Allows reaching user-specified number of triples without increasing the number of entities.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def procedure_1(self):\n        \"\"\"\n        Checks that domains and ranges are compatible with ent2classes_transitive of instantiated triples.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def procedure_2(self):\n        \"\"\"\n        Checks if the inverse relationship between r1 and r2 satisfies certain conditions.\n\n        Args:\n            self (object): The instance of the InstanceGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/main.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/main.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport argparse\nimport os\nfrom pygraft import (\n    create_json_template,\n    create_yaml_template,\n    generate,\n    generate_kg,\n    generate_schema,\n)\n\n\ndef parse_arguments():\n    pass\n\n\ndef main():\n    pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/pygraft.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/pygraft.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nfrom .class_generator import ClassGenerator\nfrom .kg_generator import InstanceGenerator\nfrom .relation_generator import RelationGenerator\nfrom .schema_constructor import SchemaBuilder\nfrom .utils import (\n    check_kg_arguments,\n    check_schema_arguments,\n    get_most_recent_subfolder,\n    initialize_folder,\n    load_config,\n    load_json_template,\n    load_yaml_template,\n    print_ascii_header,\n)\n\n\ndef create_template(extension=\"yml\"):\n    \"\"\"\n    Creates a template file for the user to fill in.\n\n    Args:\n        extension (str, optional): File extension of the template file. Defaults to \"yml\".\n\n    Raises:\n        ValueError: If the extension is not one of the following: json, yaml, yml\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef create_json_template():\n    \"\"\"\n    Creates a json template file for the user to fill in.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef create_yaml_template():\n    \"\"\"\n    Creates a yaml template file for the user to fill in.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef generate_schema(path):\n    \"\"\"\n    Generates a schema based on the user's configuration file.\n\n    Args:\n        path (str): Path to the user's configuration file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef generate_kg(path):\n    \"\"\"\n    Generates a knowledge graph based on the user's configuration file.\n\n    Args:\n        path (str): Path to the user's configuration file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef generate(path):\n    \"\"\"\n    Generates a schema and knowledge graph based on the user's configuration file.\n\n    Args:\n        path (str): Path to the user's configuration file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/relation_generator.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/relation_generator.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport itertools\nimport json\nimport random\nfrom collections import defaultdict\nimport numpy as np\nimport pkg_resources\nfrom tabulate import tabulate\n\n\nclass RelationGenerator:\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initializes the RelationGenerator.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            **kwargs: Additional keyword arguments.\n\n        Keyword Args:\n            class_info (dict): A dictionary containing information about the classes.\n            num_relations (int): The number of relations to generate.\n            relation_specificity (float): The desired specificity of the relations.\n            prop_profiled_relations (float): The desired proportion of profiled relations.\n            profile_side (str): The side to profile relations on.\n            verbose (bool): Whether to print the relation schema.\n            prop_symmetric_relations (float): The desired proportion of symmetric relations.\n            prop_inverse_relations (float): The desired proportion of inverse relations.\n            prop_functional_relations (float): The desired proportion of functional relations.\n            prop_inverse_functional_relations (float): The desired proportion of inverse functional relations.\n            prop_transitive_relations (float): The desired proportion of transitive relations.\n            prop_subproperties (float): The desired proportion of subproperties.\n            prop_reflexive_relations (float): The desired proportion of reflexive relations.\n            prop_irreflexive_relations (float): The desired proportion of irreflexive relations.\n            prop_asymmetric_relations (float): The desired proportion of asymmetric relations.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def init_params(self, **kwargs):\n        \"\"\"\n        Initializes general relation information with user-specified parameters.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            **kwargs: Additional keyword arguments.\n\n        Keyword Args:\n            class_info (dict): A dictionary containing information about the classes.\n            num_relations (int): The number of relations to generate.\n            relation_specificity (float): The desired specificity of the relations.\n            prop_profiled_relations (float): The desired proportion of profiled relations.\n            profile_side (str): The side to profile relations on.\n            verbose (bool): Whether to print the relation schema.\n            prop_symmetric_relations (float): The desired proportion of symmetric relations.\n            prop_inverse_relations (float): The desired proportion of inverse relations.\n            prop_functional_relations (float): The desired proportion of functional relations.\n            prop_inverse_functional_relations (float): The desired proportion of inverse functional relations.\n            prop_transitive_relations (float): The desired proportion of transitive relations.\n            prop_subproperties (float): The desired proportion of subproperties.\n            prop_reflexive_relations (float): The desired proportion of reflexive relations.\n            prop_irreflexive_relations (float): The desired proportion of irreflexive relations.\n            prop_asymmetric_relations (float): The desired proportion of asymmetric relations.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def init_property_props(self, **kwargs):\n        \"\"\"\n        Initializes proportions of relation properties with user-specified parameters.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            **kwargs: Additional keyword arguments.\n\n        Keyword Args:\n            class_info (dict): A dictionary containing information about the classes.\n            num_relations (int): The number of relations to generate.\n            relation_specificity (float): The desired specificity of the relations.\n            prop_profiled_relations (float): The desired proportion of profiled relations.\n            profile_side (str): The side to profile relations on.\n            verbose (bool): Whether to print the relation schema.\n            prop_symmetric_relations (float): The desired proportion of symmetric relations.\n            prop_inverse_relations (float): The desired proportion of inverse relations.\n            prop_functional_relations (float): The desired proportion of functional relations.\n            prop_inverse_functional_relations (float): The desired proportion of inverse functional relations.\n            prop_transitive_relations (float): The desired proportion of transitive relations.\n            prop_subproperties (float): The desired proportion of subproperties.\n            prop_reflexive_relations (float): The desired proportion of reflexive relations.\n            prop_irreflexive_relations (float): The desired proportion of irreflexive relations.\n            prop_asymmetric_relations (float): The desired proportion of asymmetric relations.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def init_relations(self):\n        \"\"\"\n        Initializes the relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def generate_relation_schema(self):\n        \"\"\"\n        Generates the relation schema.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            relation_info (dict): The assembled relation information.\n        \"\"\"\n        pass\n\n    def assemble_relation_info(self):\n        \"\"\"\n        Assembles and returns information about the relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            relation_info (dict): A dictionary containing statistics about the relations.\n        \"\"\"\n        pass\n\n    def generate_relations(self):\n        \"\"\"\n        Generates relations and adds various properties to them.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def calculate_profile_ratio(self):\n        \"\"\"\n        Calculates the profile ratio.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            float: The calculated profile ratio.\n        \"\"\"\n        pass\n\n    def add_one_relation_profile(self):\n        \"\"\"\n        Adds one relation profile based on the value of `profile_side`.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_partial_relation_profile(self):\n        \"\"\"\n        Generates a partial relation profile by assigning a domain/range to a relation.\n        This function selects a relation (either from the \"domain\" or \"range\" category)\n        that has not been profiled yet and assigns a randomly sampled class to it. The\n        function also updates the relation-specificity based on the chosen class. If the\n        selected relation is transitive or symmetric, the function also assigns the\n        sampled class to the corresponding \"range\" or \"domain\" relation. If the selected\n        relation has an inverse relation, the function assigns the inverse relation the\n        same class as the selected relation, as long as it is not reflexive.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_complete_relation_profile(self):\n        \"\"\"\n        Generates a complete relation profile by assigning a domain and a range to a relation.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def calculate_relation_specificity(self):\n        \"\"\"\n        Calculates the specificity of relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def sample_class(self, current_rel_specificity):\n        \"\"\"\n        Takes in a current relative specificity value\n        and returns a random class from a list of filtered classes\n        such that the current relative specificity value converges towards user-specified value.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            current_rel_specificity (float): The current relative specificity value.\n\n        Returns:\n            str: A random class from a list of filtered classes.\n        \"\"\"\n        pass\n\n    def sample_class_constrained(self, current_rel_specificity, other_class):\n        \"\"\"\n        Returns a compatible class based on the current relational specificity and other class.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            current_rel_specificity (float): The current relational specificity.\n            other_class (str): The other class.\n\n        Returns:\n            str: A compatible class.\n        \"\"\"\n        pass\n\n    def filter_classes(self, current_rel_specificity):\n        \"\"\"\n        Filters classes based on the current relational specificity.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            current_rel_specificity (float): The current relational specificity.\n\n        Returns:\n            list: A list of filtered classes.\n        \"\"\"\n        pass\n\n    def get_one_rel_compatibilities(self):\n        \"\"\"\n        Gets all valid combinations of relation properties.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def get_inverseof_compatibilities(self):\n        \"\"\"\n        Gets all valid combinations of inverse relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def update_rel2patterns(self, property):\n        \"\"\"\n        Updates self.rel2patterns dictionary based on the given property.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            property (str): The property to add to the self.rel2patterns dictionary.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def update_pattern2rels(self):\n        \"\"\"\n        Updates self.pattern2rels dictionary.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_property(self, property):\n        \"\"\"\n        Adds properties to relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            property (str): The property to add.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_inverseof(self):\n        \"\"\"\n        Determines and adds inverse relations based on observed patterns and compatibility.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def pair_inverseof(self, rel, inv_rel):\n        \"\"\"\n        Pairs relations as inverse relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n            rel (str): The first relation.\n            inv_rel (str): The second relation.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def calculate_inverseof(self):\n        \"\"\"\n        Calculates the proportion of inverse relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            float: The proportion of inverse relations.\n        \"\"\"\n        pass\n\n    def print_schema(self):\n        \"\"\"\n        Prints the relation schema and\n        displays various metrics and values related to the relations.\n\n        Args:\n            self (object): The instance of the RelationGenerator.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/schema_constructor.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/schema_constructor.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\nimport json\nimport os\nfrom datetime import datetime\nfrom owlready2 import *\nfrom pygraft.utils import reasoner\nfrom rdflib import OWL, RDF, RDFS, Graph, Namespace, URIRef\nfrom tqdm.auto import tqdm\n\n\nclass SchemaBuilder:\n    def __init__(self, class_info, relation_info, folder_name, format):\n        \"\"\"\n        Initializes the SchemaBuilder class.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n            class_info (dict): A dictionary containing class information.\n            relation_info (dict): A dictionary containing relation information.\n            folder_name (str): The name of the folder to be created. If None, a folder with the current date and time will be created.\n            format (str): The format of the output file. Can be either \"xml\" or \"ttl\".\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def initialize_folder(self, folder_name):\n        \"\"\"\n        Initializes a folder for output files.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n            folder_name (str): The name of the folder to be created. If None, a folder with the current date and time will be created.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def save_dict(self):\n        \"\"\"\n        Saves the dictionary containing relation information and class information to JSON files.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def building_pipeline(self):\n        \"\"\"\n        Initializes and builds the pipeline for creating the graph.\n\n        This function initializes a new graph object and sets up the necessary namespaces for ontology, RDF, and RDFS.\n        It binds the namespaces to the graph and adds the OWL ontology to the graph.\n        It also adds the CC0 license URI to the ontology.\n        After setting up the namespaces and ontology, it calls helper functions to add classes, relations, and test the schema.\n        Finally, it prints a message indicating that the schema has been created.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_classes(self):\n        \"\"\"\n        Adds classes to the graph based on the given class info.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def add_relations(self):\n        \"\"\"\n        Adds relations to the graph based on the provided relation information.\n\n        This function iterates through each relation and performs the following steps:\n        1. Creates a relation URI using the schema and the relation ID.\n        2. Adds the rdf:type property to the relation URI with a value of OWL.ObjectProperty.\n        3. If the relation has associated patterns, it adds the corresponding OWL property types to the relation URI.\n        4. If the relation is not reflexive, it adds the domain and range assertions to the relation URI.\n        5. If the relation has an inverse, it adds the inverseOf property to the relation URI.\n        6. If the relation has a superrelation, it adds the subPropertyOf property to the relation URI.\n        7. Serializes the graph to the specified output file.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def test_schema(self):\n        \"\"\"\n        Tests the schema by loading the ontology file and running a reasoner.\n\n        Args:\n            self (object): The instance of the SchemaBuilder.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/utils.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport json\nimport os\nimport pathlib\nimport pickle\nimport random\nimport shutil\nfrom datetime import datetime\nimport pkg_resources\nimport yaml\nfrom art import *\nfrom owlready2 import *\n\nfont_styles = [\"dancingfont\", \"rounded\", \"varsity\", \"wetletter\", \"chunky\"]\n\n\ndef print_ascii_header():\n    \"\"\" \"\"\"\n    pass\n\n\ndef initialize_folder(folder_name):\n    \"\"\"\n    Initializes a folder for output files.\n\n    Args:\n        self (object): The instance of the SchemaBuilder.\n        folder_name (str): The name of the folder to be created. If None, a folder with the current date and time will be created.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef load_config(path):\n    \"\"\"\n    Loads a configuration from a JSON or YAML file.\n\n    Args:\n        path (str): The path to the configuration file.\n\n    Raises:\n        ValueError: If the configuration file format is not supported.\n\n    Returns:\n        dict: The configuration dictionary.\n    \"\"\"\n    pass\n\n\ndef get_most_recent_subfolder(folder_path):\n    \"\"\"\n    Gets the most recent subfolder in the given folder path.\n\n    Args:\n        folder_path (str): The path to the folder.\n\n    Returns:\n        str or None: The name of the most recent subfolder or None if there are no subfolders.\n    \"\"\"\n    pass\n\n\ndef check_schema_arguments(config):\n    \"\"\"\n    Checks the validity of the schema arguments.\n\n    Args:\n        config (dict): The configuration dictionary.\n\n    Raises:\n        AssertionError: If the proportions of owl:Asymmetric and owl:Symmetric relations sum to more than 1,\n                        or if the proportions of owl:Irreflexive and owl:Reflexive relations sum to more than 1.\n        AssertionError: If the current PyGraft version does not handle rdfs:subPropertyOf, owl:FunctionalProperty,\n                        and owl:InverseFunctionalProperty at the same time.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef check_kg_arguments(config):\n    \"\"\"\n    Checks the validity of the knowledge graph arguments.\n\n    Args:\n        config (dict): The configuration dictionary.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef reasoner(\n    resource_file=None,\n    infer_property_values=False,\n    debug=False,\n    keep_tmp_file=False,\n    resource=\"schema\",\n):\n    \"\"\"\n    Runs the HermiT reasoner on the given OWL file.\n\n    Args:\n        resource_file (str): The path to the OWL file.\n        infer_property_values (bool): Whether to infer property values.\n        debug (bool): Whether to print the debug information.\n        keep_tmp_file (bool): Whether to keep the temporary file.\n        resource (str): The name of the resource.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef save_dict_to_text(data_dict, file_path):\n    \"\"\"\n    Saves a dictionary to a text file.\n\n    Args:\n        data_dict (dict): The dictionary to be saved.\n        file_path (str): The path to the file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef save_dict_to_pickle(data_dict, file_path):\n    \"\"\"\n    Saves a dictionary to a pickle file.\n\n    Args:\n        data_dict (dict): The dictionary to be saved.\n        file_path (str): The path to the file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef save_set_uris_to_text(set_uris, file_path):\n    \"\"\"\n    Saves a set of triples to a text file.\n\n    Args:\n        set_uris (set): The set of triples to be saved.\n        file_path (str): The path to the file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef save_set_ids_to_text(set_ids, file_path):\n    \"\"\"\n    Saves a set of triples to a text file.\n\n    Args:\n        set_ids (set): The set of triples to be saved.\n        file_path (str): The path to the file.\n\n    Returns:\n        None\n    \"\"\"\n    pass\n\n\ndef load_json(file_path):\n    \"\"\"\n    Loads a JSON file.\n\n    Args:\n        file_path (str): The path to the file.\n\n    Returns:\n        dict: The loaded JSON file.\n    \"\"\"\n    pass\n\n\ndef load_json_template():\n    \"\"\"\n    Loads a JSON file.\n\n    Args:\n        file_path (str): The path to the file.\n\n    Returns:\n        dict: The loaded JSON file.\n    \"\"\"\n    pass\n\n\ndef load_yaml_template():\n    \"\"\"\n    Loads a YAML file.\n\n    Args:\n        file_path (str): The path to the file.\n\n    Returns:\n        dict: The loaded YAML file.\n    \"\"\"\n    pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/utils_kg.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/utils_kg.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nimport numpy as np\n\n\ndef generate_weight_vector(size, spread):\n    \"\"\"\n    Generates a weight vector of size `size` with random values between 0 and 1.\n\n    Args:\n        size (int): The size of the weight vector.\n        spread (float): The spread of the weight vector.\n\n    Returns:\n        A weight vector of size `size` with random values between 0 and 1.\n    \"\"\"\n    pass\n\n\ndef generate_random_numbers(mean, std_dev, size):\n    \"\"\"\n    Generates random numbers from a normal distribution with mean `mean` and standard deviation `std_dev`.\n\n    Args:\n        mean (float): The mean of the normal distribution.\n        std_dev (float): The standard deviation of the normal distribution.\n        size (int): The size of the output array.\n\n    Returns:\n        An array of random numbers from a normal distribution with mean `mean` and standard deviation `std_dev`.\n    \"\"\"\n    pass\n\n\ndef get_fast_ratio(num_entities):\n    \"\"\"\n    Makes the KG generation process faster by lowering the diversity in entities' profiles.\n\n    Args:\n        num_entities (int): The number of entities.\n\n    Returns:\n        The fast ratio for the given number of entities.\n    \"\"\"\n    pass\n\n\ndef transitive_inference(triples, original_triples):\n    \"\"\"\n    Infers new triples to be added using transitive inference.\n\n    Args:\n        triples (set): The set of triples.\n        original_triples (set): The set of original triples.\n\n    Returns:\n        set: The set of inferred triples.\n    \"\"\"\n    pass\n\n\ndef inverse_inference(kg, inv_rel):\n    \"\"\"\n    Infers new triples to be added using inverse inference.\n\n    Args:\n        kg (set): The set of triples.\n        inv_rel (str): The inverse relation.\n\n    Returns:\n        set: The set of inferred triples.\n    \"\"\"\n    pass\n\n\ndef symmetric_inference(kg):\n    \"\"\"\n    Infers new triples to be added using symmetric inference.\n\n    Args:\n        kg (set): The set of triples.\n\n    Returns:\n        set: The set of inferred triples.\n    \"\"\"\n    pass\n\n\ndef reflexive_inference(kg):\n    \"\"\"\n    Infers new triples to be added using reflexive inference.\n\n    Args:\n        kg (set): The set of triples.\n\n    Returns:\n        set: The set of inferred triples.\n    \"\"\"\n    pass\n\n\ndef subproperty_inference(kg, super_rel):\n    \"\"\"\n    Infers new triples to be added using subproperty inference.\n\n    Args:\n        kg (set): The set of triples.\n        super_rel (str): The superproperty relation.\n\n    Returns:\n        set: The set of inferred triples.\n    \"\"\"\n    pass\n\n\ndef filter_symmetric(arr):\n    \"\"\"\n    Filters out symmetric triples from an array.\n\n    Args:\n        arr (np.ndarray): The array of triples.\n\n    Returns:\n        np.ndarray: The filtered array of triples.\n    \"\"\"\n    pass\n```"
    },
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py",
        "file_path": "pygraft/utils_schema.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as a file path. Please write a corresponding file sketch.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```\n\n---\nFile Path\n---\npygraft/utils_schema.py\n\n---\nFile Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable file sketch.\n\n```python\nfrom collections import defaultdict\n\n\ndef non_trivial_children(class2superclass_direct):\n    \"\"\"\n    Returns a list of classes that have at least one non-trivial parent.\n\n    Args:\n        class2superclass_direct (dict): A dictionary mapping classes to their direct superclasses.\n\n    Returns:\n        list: A list of classes that have at least one non-trivial parent.\n    \"\"\"\n    pass\n\n\ndef get_subclassof_count(class2layer):\n    \"\"\"\n    Returns the number of classes that have at least one subclass.\n\n    Args:\n        class2layer (dict): A dictionary mapping classes to their layers.\n\n    Returns:\n        int: The number of classes that have at least one non-trivial parent.\n    \"\"\"\n    pass\n\n\ndef get_leaves(class2superclass_direct, class2subclasses_direct):\n    \"\"\"\n    Returns a list of classes that have no subclasses, i.e. leaves.\n\n    Args:\n        class2superclass_direct (dict): A dictionary mapping classes to their direct superclasses.\n        class2subclasses_direct (dict): A dictionary mapping classes to their direct subclasses.\n\n    Returns:\n        list: A list of classes that have no subclasses.\n    \"\"\"\n    pass\n\n\ndef get_max_depth(layer2classes):\n    \"\"\"\n    Returns the maximum depth of the schema.\n\n    Args:\n        layer2classes (dict): A dictionary mapping layers to classes.\n\n    Returns:\n        int: The maximum depth of the schema.\n    \"\"\"\n    pass\n\n\ndef calculate_inheritance_ratio(class2superclass_direct, class2subclasses_direct):\n    \"\"\"\n    Calculates the inheritance ratio of the schema.\n\n    Args:\n        class2superclass_direct (dict): A dictionary mapping classes to their direct superclasses.\n        class2subclasses_direct (dict): A dictionary mapping classes to their direct subclasses.\n\n    Returns:\n        float: The inheritance ratio of the schema.\n    \"\"\"\n    pass\n\n\ndef calculate_average_depth(layer2classes):\n    \"\"\"\n    Calculates the average depth of the schema.\n\n    Args:\n        layer2classes (dict): A dictionary mapping layers to classes.\n\n    Returns:\n        float: The average depth of the schema.\n    \"\"\"\n    pass\n\n\ndef calculate_class_disjointness(class2disjoint, num_classes):\n    \"\"\"\n    Calculates the class disjointness of the schema.\n\n    Args:\n        class2disjoint (dict): A dictionary mapping classes to their disjoint classes.\n        num_classes (int): The number of classes.\n\n    Returns:\n        float: The class disjointness of the schema.\n    \"\"\"\n    pass\n\n\ndef get_all_superclasses(class_name, direct_class2superclass):\n    \"\"\"\n    Returns a list of all superclasses of a given class.\n\n    Args:\n        class_name (str): The name of the class.\n        direct_class2superclass (dict): A dictionary mapping classes to their direct superclasses.\n\n    Returns:\n        list: A list of all superclasses of the given class.\n    \"\"\"\n    pass\n\n\ndef get_all_subclasses(transitive_class2superclass):\n    \"\"\"\n    Returns a dictionary mapping classes to their transitive subclasses.\n\n    Args:\n        transitive_class2superclass (dict): A dictionary mapping classes to their transitive superclasses.\n\n    Returns:\n        dict: A dictionary mapping classes to their subclasses.\n    \"\"\"\n    pass\n\n\ndef extend_class_mappings(direct_class2superclass):\n    \"\"\"\n    Extends the class mappings to include transitive superclasses and subclasses.\n\n    Args:\n        direct_class2superclass (dict): A dictionary mapping classes to their direct superclasses.\n\n    Returns:\n        tuple: A tuple containing the extended class mappings.\n    \"\"\"\n    pass\n\n\ndef generate_class2layer(layer2classes):\n    \"\"\"\n    Generates a dictionary mapping classes to their layers.\n\n    Args:\n        layer2classes (dict): A dictionary mapping layers to classes.\n\n    Returns:\n        dict: A dictionary mapping classes to their layers.\n    \"\"\"\n    pass\n```"
    }
]