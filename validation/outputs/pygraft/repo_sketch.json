[
    {
        "readme": "# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```",
        "instruction": "Below is a detailed README.md of repository. Please write a repository sketch in the form of a tree, including all folders, files, as well as imports information if necessary.\n\n---\nREADME.md\n---\n# PyGraft: Configurable Generation of Synthetic Schemas and Knowledge Graphs at Your Fingertips\n\nThis is the open-source implementation of PyGraft, initially presented in [this paper](https://arxiv.org/pdf/2309.03685.pdf).\n\nPyGraft is an open-source Python library for generating synthetic yet realistic schemas and (KGs) based on user-specified parameters. The generated resources are domain-agnostic, i.e. they are not tied to a specific application field.\n\nBeing able to synthesize schemas and KGs is an important milestone for conducting research in domains where data is sensitive or not readily available. PyGraft allows researchers and practitioners to generate schemas and KGs on the fly, provided minimal knowledge about the desired specifications. \n\nPyGraft has the following features:\n- possibility to generate a schema, a KG, or both\n- highly-tunable process based on a broad array of user-specified parameters\n- schemas and KGs are built with an extended set of RDFS and OWL constructs\n- logical consistency is ensured by the use of a DL reasoner (HermiT)\n\n## PyGraft Overview\n\nThe contributions of PyGraft are as follows:\n\n- To the best of our knowledge, PyGraft is the first generator able to synthesize both schemas and KGs in a single pipeline.\n\n- The generated schemas and KGs are described with an extended set of RDFS and OWL constructs, allowing for both fine-grained resource descriptions and strict compliance with common Semantic Web standards.\n\n- A broad range of parameters can be specified by the user. These allow for creating an infinite number of graphs with different characteristics. More details on parameters can be found in the [Parameters section of the official documentation](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFrom a high-level perspective, the entire PyGraft generation pipeline is depicted in Figure 1. In particular, Class and Relation Generators are initialized with user-specified parameters and used to build the schema incrementally. The logical consistency of the schema is subsequently checked using the HermiT reasoner from [owlready2](https://github.com/pwin/owlready2/). If you are also interested in generating a KG based on this schema, the KG Generator is initialized with KG-related parameters and fused with the previously generated schema to sequentially build the KG. Ultimately, the logical consistency of the resulting KG is (again) assessed using HermiT.\n\n\n## Usage\n\nOnce installed, PyGraft can be loaded with:\n\n```python\nimport pygraft\n```\n\nImportantly, you can access all the functions with:\n\n```python\npygraft.__all__\n```\n\n### Generating a Schema\n\nLet us assume we are only interested in generating a schema. We first need to retrieve the template configuration file (e.g. a ``.yaml`` configuration file), which is as simple as calling ``create_yaml_template()``:\n\n```python\npygraft.create_yaml_template()\n```\n\nNow, the template has been generated under the current working directory, and is named ``template.yml`` by default.\n\nThis file contains all the tunable parameters. For more details on their meanings, please check the [Parameters section](https://pygraft.readthedocs.io/en/latest/references/parameters.html).\n\nFor the sake of simplicity, we do not plan to modify this template and stick with the default parameter values.\n\nGenerating an ontology is made possible via the ``generate_schema(path)`` function, which only requires the relative path to the configuration file.\n\n> [!IMPORTANT] \n> For the following steps, i.e. generating a schema and a KG, you need Java to be installed and the $JAVA_HOME environment variable to be properly assigned. This is because the HermiT reasoner currently runs using Java.\n\nIn our case, the configuration file is named ``template.yml`` and is located in the current working directory, thereby:\n\n```python\npygraft.generate_schema(\"template.yml\")\n```\n\nThe generated schema can be retrieved in ``output/template/schema.rdf``. Additional files are created during the process: ``output/template/class_info.json`` and ``output/template/relation_info.json``. These files give important information about the classes and relations of the generated schema, respectively.\n\n### Generating a KG\n\nLet us now explore how to use PyGraft to generate a KG. In this section, we assume we already have a schema, that will serve as a blueprint for generating our KG. We can use the same configuration file as before \u2013 as it also contained parameters related to the KG generation (although not used before, since we only asked for a schema) \u2013 to generate a KG:\n\n```python\npygraft.generate_kg(\"template.yml\")\n```\n\nThe generated KG can be retrieved in ``output/template/full_graph.rdf``. It combines information inherited from ``output/template/schema.rdf`` (i.e. ontological information) with information related to individuals.\n\n### Full Pipeline Execution\n\nIn most cases, one wants to generate both a schema and a KG in a single process. PyGraft allows this with the ``generate(path)`` function, which operates just as the aforedescribed two functions ``generate_schema(path)`` and ``generate_kg(path)``:\n\n```python\npygraft.generate(\"template.yml\")\n```\n\n---\nRepository Sketch\n---\n",
        "input": "",
        "output": "Here is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 docs\n|   \u2514\u2500\u2500 source\n|       \u251c\u2500\u2500 conf.py\n\u2514\u2500\u2500 pygraft\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 class_generator.py\n    \u251c\u2500\u2500 kg_generator.py\n    \u251c\u2500\u2500 main.py # from pygraft import (;\n    \u251c\u2500\u2500 pygraft.py\n    \u251c\u2500\u2500 relation_generator.py\n    \u251c\u2500\u2500 schema_constructor.py\n    \u251c\u2500\u2500 utils.py\n    \u251c\u2500\u2500 utils_kg.py\n    \u2514\u2500\u2500 utils_schema.py\n```"
    }
]