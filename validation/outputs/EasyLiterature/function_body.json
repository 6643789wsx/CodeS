[
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```",
        "current_file_path": "easy_literature/DBLP.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```\n\n---\nFunction Complement\n---\ndef set_proxy(self, proxy_address=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy(self, proxy_address=None):\n    \"\"\"set proxy handler\n\n    Aargs:\n        proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n    Returns:\n        A proxy handler object.\n    \"\"\"\n    pass\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```",
        "current_file_path": "easy_literature/DBLP.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```\n\n---\nFunction Complement\n---\ndef extract_json_info(self, item):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_json_info(self, item):\n    \"\"\"Extract bib json information from requests.get().json()\n\n    Args:\n        item (json object): obtained by requests.get().json()\n\n    Returns:\n        A dict containing the paper information.\n    \"\"\"\n    trial_num = 0\n    while trial_num < 10:\n        trial_num += 1\n        try:\n            results = dblp.search([item])\n            break\n        except:\n            if trial_num == 10:\n                results = pd.DataFrame({\"A\": []})\n            else:\n                pass\n    if not results.empty:\n        if \"CoRR\" in [str(venue) for venue in results[\"Where\"]]:\n            journal = \"CoRR\"\n        for venue in results[\"Where\"]:\n            if str(venue) != \"CoRR\":\n                journal = str(venue)\n                break\n        str(results[\"Where\"])\n        bib_dict = {\n            \"title\": str(results[\"Title\"][0]),\n            \"author\": \" and \".join([str(Entry) for Entry in results[\"Authors\"][0]]),\n            \"journal\": journal,\n            \"year\": str(results[\"Year\"][0]),\n            \"url\": str(results[\"Link\"][0]),\n            \"pdf_link\": None,\n            \"cited_count\": None,\n        }\n    else:\n        bib_dict = None\n    return bib_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```",
        "current_file_path": "easy_literature/DBLP.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/DBLP.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport pandas as pd\nfrom . import dblp_source as dblp\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"DBLP\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass DBLPInfo(object):\n    def set_proxy(self, proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    results = dblp.search([\"Finetunedlanguage models are zero-shot learners\"])\n    print(results)\n```\n\n---\nFunction Complement\n---\ndef get_info_by_title(self, title):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_title(self, title):\n    \"\"\"Get the meta information by the given paper title.\n\n    Args:\n        doi (str): The paper title\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n        OR\n        A list [{}, {}, {}]\n    \"\"\"\n    return self.extract_json_info(title)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/GoogleScholar.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef set_proxy(self, proxy_name=\"free\", proxy_address=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy(self, proxy_name=\"free\", proxy_address=None):\n    \"\"\"set proxy handler\n\n    Aargs:\n        proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n    Returns:\n        A proxy handler object.\n    \"\"\"\n    if proxy_address:\n        sucess = False\n        pg = ProxyGenerator()\n        if proxy_name == \"free\":\n            sucess = pg.FreeProxies()\n        elif proxy_name == \"single\":\n            sucess = pg.SingleProxy(http=proxy_address, https=proxy_address)\n        elif proxy_name == \"Scraper\":\n            sucess = pg.ScraperAPI(\"a44bd5be9f56b1be9d6e40116ea4b440\")\n        logger.info(f\"Scholarly using {proxy_name} proxy.\")\n        logger.info(f\"Proxy setup sucess: {sucess}.\")\n        scholarly.use_proxy(pg)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/GoogleScholar.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef extract_json_info(self, item):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_json_info(self, item):\n    \"\"\"Extract bib json information from requests.get().json()\n\n    Args:\n        item (json object): obtained by requests.get().json()\n\n    Returns:\n        A dict containing the paper information.\n    \"\"\"\n    bib_dict = None\n    trial_num = 0\n    while trial_num < 9:\n        try:\n            trial_num += 1\n            pubs_iter = scholarly.search_pubs(item)\n            dictinfo = next(pubs_iter)\n            bib_dict = {\n                \"title\": dictinfo[\"bib\"][\"title\"].replace(\"\\n\", \"\"),\n                \"author\": \" and \".join(dictinfo[\"bib\"][\"author\"]),\n                \"journal\": dictinfo[\"bib\"][\"venue\"],\n                \"year\": dictinfo[\"bib\"][\"pub_year\"],\n                \"url\": dictinfo[\"pub_url\"],\n                \"pdf_link\": dictinfo[\"eprint_url\"],\n                \"cited_count\": dictinfo[\"num_citations\"],\n            }\n            break\n        except:\n            pass\n    return bib_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/GoogleScholar.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/GoogleScholar.py`.\n\n```python\nimport logging\nfrom scholarly import ProxyGenerator, scholarly\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"GoogleScholar\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass GscholarInfo(object):\n    def set_proxy(self, proxy_name=\"free\", proxy_address=None):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    gscholar_info = GscholarInfo()\n    gscholar_info.set_proxy(proxy_name=\"free\")\n    bib_arxiv = gscholar_info.get_info_by_title(title)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_title(self, title):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_title(self, title):\n    \"\"\"Get the meta information by the given paper title.\n\n    Args:\n        doi (str): The paper title\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n        OR\n        A list [{}, {}, {}]\n    \"\"\"\n    return self.extract_json_info(title)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/arxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef __init__(self):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self):\n    self.base_url = \"http://export.arxiv.org/api/query\"\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/arxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef set_proxy_handler(self, proxy):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy_handler(self, proxy):\n    \"\"\"set proxy handler\n\n    Aargs:\n        proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n    Returns:\n        A proxy handler object.\n    \"\"\"\n    proxy_handler = ProxyHandler(\n        {\"http\": f\"http://{proxy}\", \"https\": f\"https://{proxy}\"}\n    )\n    return proxy_handler\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/arxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef extract_json_info(self, item):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_json_info(self, item):\n    \"\"\"Extract bib json information from requests.get().json()\n\n    Args:\n        item (json object): obtained by requests.get().json()\n\n    Returns:\n        A dict containing the paper information.\n    \"\"\"\n    paper_url = item.link\n    title = item.title\n    journal = \"arxiv\"\n    published = item.published.split(\"-\")\n    if len(published) > 1:\n        year = published[0]\n    else:\n        year = \" \"\n    authors = item.authors\n    if len(authors) > 0:\n        first_author = authors[0][\"name\"].split(\" \")\n        authors = \" and \".join([author[\"name\"] for author in authors])\n    else:\n        first_author = authors\n        authors = authors\n    bib_dict = {\n        \"title\": title,\n        \"author\": authors,\n        \"journal\": journal,\n        \"year\": year,\n        \"url\": paper_url,\n        \"pdf_link\": item.link.replace(\"abs\", \"pdf\") + \".pdf\",\n        \"cited_count\": None,\n    }\n    return bib_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/arxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_arxivid(self, arxivId, handler=False):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_arxivid(self, arxivId, handler=False):\n    \"\"\"Get the meta information by the given paper arxiv_id.\n\n    Args:\n        doi (str): The arxiv Id\n        handler (handler object): use proxy\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n    \"\"\"\n    params = \"?search_query=id:\" + quote(unidecode(arxivId))\n    try:\n        if handler:\n            result = feedparser.parse(self.base_url + params, handlers=[handler])\n        else:\n            result = feedparser.parse(self.base_url + params)\n        items = result.entries\n        item = items[0]\n        if \"arxiv_doi\" in item:\n            doi = item[\"arxiv_doi\"]\n            crossref_info = crossrefInfo()\n            if handler:\n                crossref_info.set_proxy(proxy=handler.proxies[\"http\"].split(\"//\")[-1])\n            return crossref_info.get_info_by_doi(doi)\n        else:\n            return self.extract_json_info(item)\n    except:\n        logger.error(\"DOI: {} is error.\".format(arxivId))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/arxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/arxiv.py`.\n\n```python\nimport logging\nfrom urllib.request import ProxyHandler\nimport feedparser\n\ntry:\n    from urllib import quote\nexcept ImportError:\n    from urllib.parse import quote\nfrom unidecode import unidecode\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"arxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass arxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy_handler(self, proxy):\n        \"\"\"set proxy handler\n\n        Aargs:\n            proxy (str): proxy (str): The proxy adress. e.g 127.0.1:1123\n\n        Returns:\n            A proxy handler object.\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_arxivid(self, arxivId, handler=False):\n        \"\"\"Get the meta information by the given paper arxiv_id.\n\n        Args:\n            doi (str): The arxiv Id\n            handler (handler object): use proxy\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title, field=\"ti\"):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"2208.05623\"\n    title = \"Heterogeneous Graph Attention Network\"\n    arxiv_info = arxivInfo()\n    arxiv_info.set_proxy_handler(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_arxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_title(self, title, field=\"ti\"):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_title(self, title, field=\"ti\"):\n    \"\"\"Get the meta information by the given paper title.\n\n    Args:\n        doi (str): The paper title\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n        OR\n        A list [{}, {}, {}]\n    \"\"\"\n    params = \"?search_query=\" + field + \":\" + quote(unidecode(title))\n    url = self.base_url + params\n    try:\n        result = feedparser.parse(url)\n        items = result.entries\n        print(len(items))\n        for i, item in enumerate(items):\n            title_item = item.title\n            try:\n                title_item = title_item.decode(\"utf-8\")\n            except:\n                pass\n            item.title = title_item\n            if title_item.lower() == title.lower():\n                return self.extract_json_info(item)\n            items[i] = item\n        return [self.extract_json_info(it) for it in items]\n    except:\n        logger.error(\"Title: {} is error.\".format(title))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/crossref.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef __init__(self):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self):\n    self.sess = requests.Session()\n    self.sess.headers = HEADERS\n    self.base_url = \"http://api.crossref.org/\"\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/crossref.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef set_proxy(self, proxy=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy(self, proxy=None):\n    \"\"\"set proxy for session\n\n    Args:\n        proxy (str): The proxy adress. e.g 127.0.1:1123\n    Returns:\n        None\n    \"\"\"\n    if proxy:\n        self.sess.proxies = {\"http\": proxy, \"https\": proxy}\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/crossref.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef extract_json_info(self, bib):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_json_info(self, bib):\n    \"\"\"Extract bib json information from requests.get().json()\n\n    Args:\n        bib (json object): obtained by requests.get().json()\n\n    Returns:\n        A dict containing the paper information.\n    \"\"\"\n    pub_date = [str(i) for i in bib[\"published\"][\"date-parts\"][0]]\n    pub_date = \"-\".join(pub_date)\n    if \"author\" in bib.keys():\n        authors = \" and \".join(\n            [\n                (i[\"family\"] + \" \" + i[\"given\"])\n                for i in bib[\"author\"]\n                if \"family\" and \"given\" in i.keys()\n            ]\n        )\n    else:\n        authors = \"No author\"\n    if \"short-container-title\" in bib.keys():\n        try:\n            journal = bib[\"short-container-title\"][0]\n        except:\n            journal = \"No journal\"\n    else:\n        try:\n            journal = bib[\"container-title\"][0]\n        except:\n            journal = \"No journal\"\n    bib_dict = {\n        \"title\": bib[\"title\"][0],\n        \"author\": authors,\n        \"journal\": journal,\n        \"year\": pub_date,\n        \"url\": bib[\"URL\"],\n        \"pdf_link\": bib[\"link\"][0][\"URL\"],\n        \"cited_count\": bib[\"is-referenced-by-count\"],\n    }\n    return bib_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/crossref.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_doi(self, doi):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_doi(self, doi):\n    \"\"\"Get the meta information by the given paper DOI number.\n\n    Args:\n        doi (str): The paper DOI number\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n    \"\"\"\n    url = \"{}works/{}\"\n    url = url.format(self.base_url, doi)\n    try:\n        r = self.sess.get(url)\n        bib = r.json()[\"message\"]\n        return self.extract_json_info(bib)\n    except:\n        logger.error(\"DOI: {} is error.\".format(doi))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/crossref.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/crossref.py`.\n\n```python\nimport logging\nimport requests\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"crossref\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass crossrefInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, bib):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            bib (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_doi(self, doi):\n        \"\"\"Get the meta information by the given paper DOI number.\n\n        Args:\n            doi (str): The paper DOI number\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1038/s41467-022-29269-6\"\n    crossref_info = crossrefInfo()\n    crossref_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_doi = crossref_info.get_info_by_doi(doi)\n    print(bib_doi)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_title(self, title):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_title(self, title):\n    \"\"\"Get the meta information by the given paper title.\n\n    Args:\n        doi (str): The paper title\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n        OR\n        A list [{}, {}, {}]\n    \"\"\"\n    url = self.base_url + \"works\"\n    params = {\"query.bibliographic\": title, \"rows\": 20}\n    try:\n        r = self.sess.get(url, params=params)\n        items = r.json()[\"message\"][\"items\"]\n        for i, item in enumerate(items):\n            title_item = item[\"title\"][0]\n            try:\n                title_item = title_item.decode(\"utf-8\")\n            except:\n                pass\n            item[\"title\"][0] = title_item\n            if title_item.lower() == title.lower():\n                return self.extract_json_info(item)\n            items[i] = item\n        return [self.extract_json_info(it) for it in items]\n    except:\n        logger.error(\"Title: {} is error.\".format(title))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    pass\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    pass\n```",
        "current_file_path": "easy_literature/dblp_source.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    pass\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    pass\n```\n\n---\nFunction Complement\n---\ndef query_db(pub_string=STRINGS_FOR_TEST):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    resp = requests.get(PUB_SEARCH_URL, params={\"q\": pub_string})\n    return BeautifulSoup(resp.content)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    pass\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    pass\n```",
        "current_file_path": "easy_literature/dblp_source.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    pass\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    pass\n```\n\n---\nFunction Complement\n---\ndef get_pub_data(pub):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    ptype = \"nothing\"\n    link = \"nothing\"\n    authors = []\n    title = \"nothing\"\n    where = \"nothing\"\n    if \"year\" in pub.get(\"class\"):\n        return int(pub.contents[0])\n    else:\n        ptype = pub.attrs.get(\"class\")[1]\n        for content_item in pub.contents:\n            class_of_content_item = content_item.attrs.get(\"class\", [0])\n            if \"data\" in class_of_content_item:\n                for author in content_item.findAll(\n                    \"span\", attrs={\"itemprop\": \"author\"}\n                ):\n                    authors.append(author.text)\n                title = content_item.find(\"span\", attrs={\"class\": \"title\"}).text\n                for where_data in content_item.findAll(\n                    \"span\", attrs={\"itemprop\": \"isPartOf\"}\n                ):\n                    found_where = where_data.find(\"span\", attrs={\"itemprop\": \"name\"})\n                    if found_where:\n                        where = found_where.text\n            elif \"publ\" in class_of_content_item:\n                link = content_item.contents[0].find(\"a\").attrs.get(\"href\", \"nothing\")\n    return {\n        \"Type\": ptype,\n        \"Link\": link,\n        \"Authors\": authors,\n        \"Title\": title,\n        \"Where\": where,\n    }\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    pass\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    pass\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    \"\"\"TODO\"\"\"\n```",
        "current_file_path": "easy_literature/dblp_source.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/dblp_source.py`.\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nSTRINGS_FOR_TEST = [\"Collaborative Writing\"]\nDBLP_BASE_URL = \"http://dblp.uni-trier.de/\"\nPUB_SEARCH_URL = DBLP_BASE_URL + \"search/publ/\"\n\n\ndef query_db(pub_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the BeautifulSoup object of a query to DBLP\n\n    :param pub_string: A list of strings of keywords\n    :return: BeautifulSoup: A BeautifulSoup Object\n    \"\"\"\n    pass\n\n\ndef get_pub_data(pub):\n    \"\"\"\n    Extracts the information about a publication from a BeautifulSoup object\n\n    :param pub: A BeautifulSoup Object with Publication Information\n    :return: dict: All Information of this Publication\n    \"\"\"\n    pass\n\n\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    \"\"\"TODO\"\"\"\n```\n\n---\nFunction Complement\n---\ndef search(search_string=STRINGS_FOR_TEST):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef search(search_string=STRINGS_FOR_TEST):\n    \"\"\"\n    returns the information found in a search query to dblp as a pandas dataframe.\n    Shows the following information:\n        - Authors\n        - Link to Publication\n        - Title\n        - Type (Article, Proceedings etc.)\n        - Where it was published\n        - Year of publication\n    :param search_string: A List of Strings of Keywords, that should be searched for\n    :return: pd.DataFrame: A Dataframe with all data\n    \"\"\"\n    soup = query_db(search_string)\n    pub_list_raw = soup.find(\"ul\", attrs={\"class\": \"publ-list\"})\n    pub_list_data = []\n    curr_year = 0\n    for child in pub_list_raw.children:\n        pub_data = get_pub_data(child)\n        if type(pub_data) == int:\n            curr_year = pub_data\n        else:\n            pub_data[\"Year\"] = curr_year\n            pub_list_data.append(pub_data)\n    return pd.DataFrame(pub_list_data)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    \"\"\"TODO\"\"\"\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```",
        "current_file_path": "easy_literature/downloads.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    \"\"\"TODO\"\"\"\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```\n\n---\nFunction Complement\n---\ndef check_string(re_exp, str):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef check_string(re_exp, str):\n    res = re.match(re_exp, str)\n    if res:\n        return True\n    else:\n        return False\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```",
        "current_file_path": "easy_literature/downloads.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```\n\n---\nFunction Complement\n---\ndef classify(identifier):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    if check_string(\"10\\\\.(?!1101)[0-9]{4}/\\\\.*\", identifier):\n        return \"doi\"\n    elif check_string(\"10\\\\.1101/\\\\.*\", identifier):\n        return \"medbiorxivId\"\n    elif check_string(\"[0-9]{2}[0-1][0-9]\\\\.[0-9]{3,}.*\", identifier) or check_string(\n        \".*/[0-9]{2}[0-1][0-9]{4}\", identifier\n    ):\n        return \"arxivId\"\n    elif check_string(\"[a-zA-Z\\\\d\\\\.-/\\\\s]*\", identifier):\n        return \"title\"\n    else:\n        return \"unrecognized\"\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    \"\"\"TODO\"\"\"\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```",
        "current_file_path": "easy_literature/downloads.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    \"\"\"TODO\"\"\"\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pass\n```\n\n---\nFunction Complement\n---\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    id_type = classify(paper_id)\n    if id_type == \"doi\":\n        logger.info(\"ID type: doi.\")\n        downloader = crossrefInfo()\n        if proxy:\n            downloader.set_proxy(proxy=proxy)\n        bib_dict = downloader.get_info_by_doi(paper_id)\n    elif id_type == \"arxivId\":\n        logger.info(\"ID type: arixiv.\")\n        downloader = arxivInfo()\n        if proxy:\n            downloader.set_proxy_handler(proxy=proxy)\n        bib_dict = downloader.get_info_by_arxivid(paper_id)\n    elif id_type == \"medbiorxivId\":\n        logger.info(\"ID type: medbiorxivId.\")\n        downloader = BMxivInfo()\n        if proxy:\n            downloader.set_proxy(proxy=proxy)\n        bib_dict = downloader.get_info_by_bmrxivid(paper_id)\n    elif id_type == \"title\":\n        logger.info(\"ID type: title.\")\n        downloader1 = GscholarInfo()\n        downloader1.set_proxy(proxy_name=gproxy_mode, proxy_address=proxy)\n        bib_dict = downloader1.get_info_by_title(paper_id)\n        downloader2 = DBLPInfo()\n        downloader2.set_proxy(proxy_address=proxy)\n        bib_dict1 = downloader2.get_info_by_title(paper_id)\n        logger.info(f\"The Google scholar bib: {bib_dict}; The DLBP bib: {bib_dict1}.\")\n        if bib_dict is not None and bib_dict1 is not None:\n            bib_dict[\"journal\"] = bib_dict1[\"journal\"]\n        elif bib_dict is None and bib_dict1 is not None:\n            bib_dict = bib_dict1\n        elif bib_dict is None and bib_dict1 is None:\n            logger.info(\"Title not found on DLBP and Google scholar.\")\n    else:\n        pass\n    try:\n        return bib_dict\n    except:\n        pass\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    \"\"\"TODO\"\"\"\n```",
        "current_file_path": "easy_literature/downloads.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/downloads.py`.\n\n```python\nimport logging\nimport os\nimport platform\nimport re\nfrom .arxiv import arxivInfo\nfrom .crossref import crossrefInfo\nfrom .DBLP import DBLPInfo\nfrom .GoogleScholar import GscholarInfo\nfrom .medbiorxiv import BMxivInfo\nfrom .pdfs import pdfDownload\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"Downloads\")\nlogger.setLevel(logging.INFO)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\ndef check_string(re_exp, str):\n    pass\n\n\ndef classify(identifier):\n    \"\"\"\n    Classify the type of paper_id:\n    arxivId - arxivId\n    doi - digital object identifier\n    medbiorxivId - medrxiv or biorxiv id\n    title - title\n    \"\"\"\n    pass\n\n\ndef get_paper_info_from_paperid(paper_id, proxy=None, gproxy_mode=\"free\"):\n    pass\n\n\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    \"\"\"TODO\"\"\"\n```\n\n---\nFunction Complement\n---\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_paper_pdf_from_paperid(paper_id, path, proxy=None, direct_url=None):\n    pdf_downloader = pdfDownload()\n    if proxy:\n        pdf_downloader.set_proxy(proxy=proxy)\n    if direct_url:\n        content = pdf_downloader.get_pdf_from_direct_url(direct_url)\n        if not content:\n            content = pdf_downloader.get_pdf_from_sci_hub(paper_id)\n    else:\n        content = pdf_downloader.get_pdf_from_sci_hub(paper_id)\n    try:\n        system = platform.system()\n        if system == \"Windows\":\n            path = path.replace(\"/\", \"\\\\\")\n            pdf_dir = path.rsplit(\"\\\\\", 1)[0]\n        else:\n            pdf_dir = path.rsplit(\"/\", 1)[0]\n        if not os.path.exists(pdf_dir):\n            os.makedirs(pdf_dir)\n        pdf_downloader._save(content[\"pdf\"], path)\n    except:\n        pass\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    \"\"\"TODO\"\"\"\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "current_file_path": "easy_literature/easyliter.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    \"\"\"TODO\"\"\"\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\nFunction Complement\n---\ndef set_args():\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_args():\n    parser = argparse.ArgumentParser(description=\"EasyLiterature\")\n    parser.add_argument(\n        \"-i\",\n        \"--input\",\n        required=True,\n        type=str,\n        default=None,\n        help=\"The path to the note file or note file folder.\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        type=str,\n        default=None,\n        help=\"Folder path to save paper pdfs and images. NOTE: MUST BE FOLDER.\",\n    )\n    parser.add_argument(\n        \"-p\",\n        \"--proxy\",\n        type=str,\n        default=None,\n        help=\"The proxy address. e.g. 127.0.0.1:1080. If this argument is specified, the google scholar will automatically use a free proxy (not necessarily using the specified proxy address). To use other proxies for google scholar, specify the -gp option. If you want to set up the proxies mannually, change the behaviour in GoogleScholar.set_proxy().  See more at https://scholarly.readthedocs.io/en/stable/ProxyGenerator.html.\",\n    )\n    parser.add_argument(\n        \"-gp\",\n        \"--gproxy_mode\",\n        type=str,\n        default=\"free\",\n        help=\"The proxy type used for scholarly. e.g., free, single, Scraper. (Note: 1. <free> will automatically choose a free proxy address to use, which is free, but may not be fast. 2. <single> will use the proxy address you specify. 3. <Scraper> is not free to use and need to buy the api key.).\",\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--delete\",\n        action=\"store_true\",\n        help=\"Delete unreferenced attachments in notes. Use with caution, when used, -i must be a folder path including all notes.\",\n    )\n    parser.add_argument(\n        \"-m\",\n        \"--migration\",\n        type=str,\n        default=None,\n        help=\"The pdf folder path you want to reconnect to.\",\n    )\n    args = parser.parse_args()\n    return args\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    \"\"\"TODO\"\"\"\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "current_file_path": "easy_literature/easyliter.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    \"\"\"TODO\"\"\"\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\nFunction Complement\n---\ndef check_args():\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef check_args():\n    args = set_args()\n    input_path = args.input\n    output_path = args.output\n    delete_bool = args.delete\n    migration_path = args.migration\n    proxy = args.proxy\n    gproxy_mode = args.gproxy_mode\n    return input_path, output_path, delete_bool, proxy, migration_path, gproxy_mode\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    \"\"\"TODO\"\"\"\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "current_file_path": "easy_literature/easyliter.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    \"\"\"TODO\"\"\"\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\nFunction Complement\n---\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pdfs_path = output_path\n    if not os.path.exists(pdfs_path):\n        os.makedirs(pdfs_path)\n    with open(note_file, \"r\") as f:\n        content = f.read()\n    m = paper_recognizer.findall(content)\n    logger.info(\"Number of files to download -  {}\".format(len(m)))\n    if not m:\n        logger.info(\n            \"The file {} is not found, or there is no valid entry in the file.\".format(\n                note_file\n            )\n        )\n    else:\n        replace_dict = get_update_content(\n            m, note_file, pdfs_path, proxy=proxy, gproxy_mode=gproxy_mode\n        )\n        return replace_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    \"\"\"TODO\"\"\"\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "current_file_path": "easy_literature/easyliter.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    \"\"\"TODO\"\"\"\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\nFunction Complement\n---\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    replace_dict = get_bib_and_pdf(\n        input_path, output_path, proxy, paper_recognizer, gproxy_mode\n    )\n    if replace_dict:\n        note_modified(paper_recognizer, input_path, **replace_dict)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "current_file_path": "easy_literature/easyliter.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/easyliter.py`.\n\n```python\nimport argparse\nimport logging\nimport os\nfrom .utils import (\n    get_pdf_paths,\n    get_pdf_paths_from_notes,\n    get_pdf_paths_from_notes_dict,\n    get_update_content,\n    note_modified,\n    patternRecognizer,\n)\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"easyliter\")\nlogger.setLevel(logging.INFO)\n\n\ndef set_args():\n    pass\n\n\ndef check_args():\n    pass\n\n\ndef get_bib_and_pdf(note_file, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode):\n    pass\n\n\ndef main():\n    \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\nFunction Complement\n---\ndef main():\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef main():\n    (\n        input_path,\n        output_path,\n        delete_bool,\n        proxy,\n        migration_path,\n        gproxy_mode,\n    ) = check_args()\n    if output_path:\n        paper_recognizer = patternRecognizer(\"- \\\\{.{3,}\\\\}\")\n        if os.path.isfile(input_path):\n            logger.info(\"Updating the file {}\".format(input_path))\n            file_update(input_path, output_path, proxy, paper_recognizer, gproxy_mode)\n        elif os.path.isdir(input_path):\n            note_paths = []\n            for root, _, files in os.walk(input_path):\n                for file in files:\n                    if file.lower().endswith(\"md\") or file.lower().endswith(\"markdown\"):\n                        note_paths.append(os.path.join(root, file))\n            for note_path in note_paths:\n                logger.info(\"Updating the file {}\".format(note_path))\n                file_update(\n                    note_path, output_path, proxy, paper_recognizer, gproxy_mode\n                )\n        else:\n            logger.info(\"input path {} does not exist\".format(input_path))\n        if delete_bool:\n            if os.path.isfile(input_path):\n                logger.info(\n                    \"To delete the PDF entities unrelated to the notes, the input path must be the main notes folder!!! Please use this parameter with caution!!!\"\n                )\n            else:\n                pdf_path_recognizer = patternRecognizer(\"\\\\[pdf\\\\]\\\\(.{5,}\\\\.pdf\\\\)\")\n                pdf_paths_in_notes = get_pdf_paths_from_notes(\n                    input_path, pdf_path_recognizer\n                )\n                pdf_paths = get_pdf_paths(output_path)\n                pdf_paths_in_notes = [\n                    os.path.abspath(i).replace(\"\\\\\", \"/\") for i in pdf_paths_in_notes\n                ]\n                pdf_paths = [os.path.abspath(i).replace(\"\\\\\", \"/\") for i in pdf_paths]\n                removed_pdf_paths = list(set(pdf_paths) - set(pdf_paths_in_notes))\n                try:\n                    for pdf_p in removed_pdf_paths:\n                        os.remove(pdf_p)\n                except:\n                    pass\n                logger.info(\"Deleted {} files\".format(len(removed_pdf_paths)))\n    if migration_path:\n        pdf_path_recognizer = patternRecognizer(\"\\\\[pdf\\\\]\\\\(.{5,}\\\\.pdf\\\\)\")\n        pdf_paths = get_pdf_paths(migration_path)\n        pdf_paths_in_notes = get_pdf_paths_from_notes_dict(\n            input_path, pdf_path_recognizer\n        )\n        matched_numb = 0\n        pdf_paths_dict = {os.path.basename(i): i for i in pdf_paths}\n        for md_file, pdf_paths_ in pdf_paths_in_notes.items():\n            pdf_paths_in_notes_dict = {os.path.basename(i): i for i in pdf_paths_}\n            matched_pdfs = pdf_paths_dict.keys() & pdf_paths_in_notes_dict.keys()\n            matched_numb += len(matched_pdfs)\n            replace_paths_dict = {}\n            for matched in matched_pdfs:\n                replaced_str = os.path.relpath(pdf_paths_dict[matched], md_file).split(\n                    \"/\", 1\n                )[-1]\n                replaced_str = \"[pdf]({})\".format(replaced_str)\n                ori_str = \"[pdf]({})\".format(pdf_paths_in_notes_dict[matched])\n                replace_paths_dict[ori_str] = replaced_str\n            if replace_paths_dict:\n                note_modified(pdf_path_recognizer, md_file, **replace_paths_dict)\n        logger.info(\"Found - {} - pdf files\".format(matched_numb))\n    if not output_path and not migration_path:\n        logger.info(\"lacking the arguments -o or -m, use -h to see the help\")\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/medbiorxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef __init__(self):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self):\n    self.sess = requests.Session()\n    self.sess.headers = HEADERS\n    self.base_url = \"https://api.biorxiv.org/details/\"\n    self.servers = [\"biorxiv\", \"medrxiv\"]\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/medbiorxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef set_proxy(self, proxy=False):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy(self, proxy=False):\n    \"\"\"set proxy for session\n\n    Args:\n        proxy (str): The proxy adress. e.g 127.0.1:1123\n    Returns:\n        None\n    \"\"\"\n    if proxy:\n        self.sess.proxies = {\"http\": proxy, \"https\": proxy}\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/medbiorxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef extract_json_info(self, item):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef extract_json_info(self, item):\n    \"\"\"Extract bib json information from requests.get().json()\n\n    Args:\n        item (json object): obtained by requests.get().json()\n\n    Returns:\n        A dict containing the paper information.\n    \"\"\"\n    paper_url = f\"https://www.biorxiv.org/content/{item['doi']}\"\n    title = item[\"title\"]\n    journal = item[\"server\"]\n    published = item[\"date\"].split(\"-\")\n    if len(published) > 1:\n        year = published[0]\n    else:\n        year = \" \"\n    authors = item[\"authors\"].split(\"; \")\n    if len(authors) > 0:\n        authors = \" and \".join([author for author in authors])\n    else:\n        authors = authors\n    bib_dict = {\n        \"title\": title,\n        \"author\": authors,\n        \"journal\": journal,\n        \"year\": year,\n        \"url\": paper_url,\n        \"pdf_link\": f\"{paper_url}.full.pdf\",\n        \"cited_count\": None,\n    }\n    return bib_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/medbiorxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        pass\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_bmrxivid(self, bmrxivid):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_bmrxivid(self, bmrxivid):\n    \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n    Args:\n        doi (str): The biorxiv or medrxiv Id\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n    \"\"\"\n    urls = [(self.base_url + server + \"/\" + bmrxivid) for server in self.servers]\n    for url in urls:\n        try:\n            r = self.sess.get(url)\n            bib = r.json()[\"collection\"][-1]\n            if \"published\" in bib.keys() and bib[\"published\"] != \"NA\":\n                doi = bib[\"published\"]\n                print(doi)\n                crossref_info = crossrefInfo()\n                if len(self.sess.proxies) > 0:\n                    crossref_info.set_proxy(self.sess.proxies[\"http\"].split(\"//\")[-1])\n                return crossref_info.get_info_by_doi(doi)\n            return self.extract_json_info(bib)\n        except:\n            logger.error(\"DOI: {} is error.\".format(bmrxivid))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```",
        "current_file_path": "easy_literature/medbiorxiv.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/medbiorxiv.py`.\n\n```python\nimport logging\nimport requests\nfrom bs4 import BeautifulSoup\nfrom .crossref import crossrefInfo\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"biorxiv\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass BMxivInfo(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=False):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def extract_json_info(self, item):\n        \"\"\"Extract bib json information from requests.get().json()\n\n        Args:\n            item (json object): obtained by requests.get().json()\n\n        Returns:\n            A dict containing the paper information.\n        \"\"\"\n        pass\n\n    def get_info_by_bmrxivid(self, bmrxivid):\n        \"\"\"Get the meta information by the given paper biorxiv_id or medrxiv_id.\n\n        Args:\n            doi (str): The biorxiv or medrxiv Id\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n        \"\"\"\n        pass\n\n    def get_info_by_title(self, title):\n        \"\"\"Get the meta information by the given paper title.\n\n        Args:\n            doi (str): The paper title\n\n        Returns:\n            A dict containing the paper information.\n            {\n                \"title\": xxx,\n                \"author\": xxx,\n                \"journal\": xxx,\n                etc\n            }\n            OR\n            None\n            OR\n            A list [{}, {}, {}]\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    arxivId = \"10.1101/2022.07.28.22277637\"\n    arxiv_info = BMxivInfo()\n    arxiv_info.set_proxy(proxy=\"127.0.1:1123\")\n    bib_arxiv = arxiv_info.get_info_by_bmrxivid(arxivId)\n    print(bib_arxiv)\n    print(\"\\n\")\n```\n\n---\nFunction Complement\n---\ndef get_info_by_title(self, title):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_info_by_title(self, title):\n    \"\"\"Get the meta information by the given paper title.\n\n    Args:\n        doi (str): The paper title\n\n    Returns:\n        A dict containing the paper information.\n        {\n            \"title\": xxx,\n            \"author\": xxx,\n            \"journal\": xxx,\n            etc\n        }\n        OR\n        None\n        OR\n        A list [{}, {}, {}]\n    \"\"\"\n    base_url = \"https://www.biorxiv.org/search/{}%20jcode%3Amedrxiv%7C%7Cbiorxiv%20numresults%3A25%20\\\\sort%3Arelevance-rank%20\\x0cormat_result%3Astandard\"\n    query = title.replace(\" \", \"%252B\")\n    url = base_url.format(query)\n    try:\n        result = self.sess.get(url)\n        soup = BeautifulSoup(result.content, \"lxml\")\n        soup_items = soup.find_all(\n            \"div\",\n            class_=\"highwire-cite highwire-cite-highwire-article highwire-citation-biorxiv-article-pap-list clearfix\",\n        )\n        soup_dict = dict()\n        for sp in soup_items:\n            key = sp.find(\"a\", class_=\"highwire-cite-linked-title\").span.text\n            value = (\n                sp.find(\n                    \"span\", class_=\"highwire-cite-metadata-doi highwire-cite-metadata\"\n                )\n                .text.split(\"org/\")[-1]\n                .split(\"v\")[0]\n                .replace(\" \", \"\")\n            )\n            soup_dict[key] = value\n        for item_title, item_doi in soup_dict.items():\n            try:\n                item_title = item_title.decode(\"utf-8\")\n            except:\n                pass\n            if item_title.lower() == title.lower():\n                return self.get_info_by_bmrxivid(item_doi)\n        return [self.get_info_by_bmrxivid(it) for it in soup_dict.values()]\n    except:\n        logger.error(\"Title: {} is error.\".format(title))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        \"\"\"TODO\"\"\"\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef __init__(self):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self):\n    self.sess = requests.Session()\n    self.sess.headers = HEADERS\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef set_proxy(self, proxy=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef set_proxy(self, proxy=None):\n    \"\"\"set proxy for session\n\n    Args:\n        proxy (str): The proxy adress. e.g 127.0.1:1123\n    Returns:\n        None\n    \"\"\"\n    if proxy:\n        self.sess.proxies = {\"http\": proxy, \"https\": proxy}\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef _get_available_scihub_urls(self):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef _get_available_scihub_urls(self):\n    \"\"\"\n    Finds available scihub urls via https://lovescihub.wordpress.com/ or\n    https://sci-hub.now.sh/\n    \"\"\"\n    urls = []\n    res = self.sess.get(\"https://lovescihub.wordpress.com/\")\n    s = BeautifulSoup(res.content, \"html.parser\")\n    for a in s.find(\"div\", class_=\"entry-content\").find_all(\"a\", href=True):\n        if \"sci-hub.\" in a[\"href\"]:\n            urls.append(a[\"href\"])\n    return urls\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef fetch(self, url, auth=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef fetch(self, url, auth=None):\n    \"\"\"Fetch pdf\n\n    Args:\n        url (str):\n\n    Returns:\n        A dict OR None\n    \"\"\"\n    try:\n        r = self.sess.get(url, auth=auth)\n        if r.headers[\"Content-Type\"] != \"application/pdf\":\n            logger.info(\"Failed to fetch pdf with url: {}\".format(url))\n        else:\n            return {\"pdf\": r.content, \"url\": url}\n    except:\n        logger.error(\"Failed to open url: {}\".format(url))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        \"\"\"TODO\"\"\"\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        \"\"\"TODO\"\"\"\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef get_pdf_from_direct_url(self, url, auth=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pdf_from_direct_url(self, url, auth=None):\n    return self.fetch(url, auth=auth)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        \"\"\"TODO\"\"\"\n\n    def _save(self, content, path):\n        pass\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef get_pdf_from_sci_hub(self, identifier, auth=None):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pdf_from_sci_hub(self, identifier, auth=None):\n    \"\"\"Fetch pdf from sci-hub based on doi or url\n\n    Args:\n        identifier (str): DOI or url\n        auth (tuple): (\"user\", \"passwd\")\n\n    Returns:\n        A dict OR None\n    \"\"\"\n    for base_url in self._get_available_scihub_urls():\n        r = self.sess.get(base_url + \"/\" + identifier, auth=auth)\n        soup = BeautifulSoup(r.content, \"html.parser\")\n        pdf_div_names = [\"iframe\", \"embed\"]\n        for pdf_div_name in pdf_div_names:\n            pdf_div = soup.find(pdf_div_name)\n            if pdf_div != None:\n                break\n        try:\n            url_parts = urlsplit(pdf_div.get(\"src\"))\n            if url_parts[1]:\n                if url_parts[0]:\n                    pdf_url = urlunsplit(\n                        (url_parts[0], url_parts[1], url_parts[2], \"\", \"\")\n                    )\n                else:\n                    pdf_url = urlunsplit((\"https\", url_parts[1], url_parts[2], \"\", \"\"))\n            else:\n                pdf_url = urlunsplit(\n                    (\"https\", urlsplit(base_url)[1], url_parts[2], \"\", \"\")\n                )\n            return self.fetch(pdf_url, auth)\n        except:\n            pass\n    logger.info(\"Failed to fetch pdf with all sci-hub urls\")\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```",
        "current_file_path": "easy_literature/pdfs.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/pdfs.py`.\n\n```python\nimport logging\nfrom urllib.parse import urlsplit, urlunsplit\nimport requests\nfrom bs4 import BeautifulSoup\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"PDFs\")\nlogger.setLevel(logging.DEBUG)\nHEADERS = {\n    \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:27.0) Gecko/20100101 Firefox/27.0\"\n}\n\n\nclass pdfDownload(object):\n    def __init__(self):\n        pass\n\n    def set_proxy(self, proxy=None):\n        \"\"\"set proxy for session\n\n        Args:\n            proxy (str): The proxy adress. e.g 127.0.1:1123\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def _get_available_scihub_urls(self):\n        \"\"\"\n        Finds available scihub urls via https://lovescihub.wordpress.com/ or\n        https://sci-hub.now.sh/\n        \"\"\"\n        pass\n\n    def fetch(self, url, auth=None):\n        \"\"\"Fetch pdf\n\n        Args:\n            url (str):\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def get_pdf_from_direct_url(self, url, auth=None):\n        pass\n\n    def get_pdf_from_sci_hub(self, identifier, auth=None):\n        \"\"\"Fetch pdf from sci-hub based on doi or url\n\n        Args:\n            identifier (str): DOI or url\n            auth (tuple): (\"user\", \"passwd\")\n\n        Returns:\n            A dict OR None\n        \"\"\"\n        pass\n\n    def _save(self, content, path):\n        \"\"\"TODO\"\"\"\n\n\nif __name__ == \"__main__\":\n    doi = \"10.1145/3308558.3313562\"\n    pdf_download = pdfDownload()\n    pdf_download.set_proxy(\"127.0.1:1123\")\n    pdf_dict = pdf_download.get_pdf_from_sci_hub(doi)\n    if pdf_dict:\n        print(pdf_dict[\"url\"])\n        pdf_download.download(pdf_dict[\"pdf\"], \"/home/admin/tmp.pdf\")\n```\n\n---\nFunction Complement\n---\ndef _save(self, content, path):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef _save(self, content, path):\n    with open(path, \"wb\") as f:\n        f.write(content)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        \"\"\"TODO\"\"\"\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        \"\"\"TODO\"\"\"\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef __init__(self, regular_rule):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef __init__(self, regular_rule):\n    self.pattern = re.compile(regular_rule)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        \"\"\"TODO\"\"\"\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        \"\"\"TODO\"\"\"\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef match(self, string):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef match(self, string):\n    return self.pattern.match(string)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        \"\"\"TODO\"\"\"\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        \"\"\"TODO\"\"\"\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef findall(self, string):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef findall(self, string):\n    return self.pattern.findall(string)\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        \"\"\"TODO\"\"\"\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        \"\"\"TODO\"\"\"\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef multiple_replace(self, content, **replace_dict):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef multiple_replace(self, content, **replace_dict):\n    def replace_(value):\n        match = value.group()\n        if match in replace_dict.keys():\n            return replace_dict[match]\n        else:\n            return (\n                match\n                + \" **Not Correct, Check it. Maybe mannual update & download is needed.**\"\n            )\n\n    replace_content = self.pattern.sub(replace_, content)\n    return replace_content\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef multiple_replace(self, content, **replace_dict):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef multiple_replace(self, content, **replace_dict):\n    match = value.group()\n    if match in replace_dict.keys():\n        return replace_dict[match]\n    else:\n        return (\n            match\n            + \" **Not Correct, Check it. Maybe mannual update & download is needed.**\"\n        )\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef note_modified(pattern_recog, md_file, **replace_dict):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    with open(md_file, \"r\") as f:\n        content = f.read()\n    replaced_content = pattern_recog.multiple_replace(content, **replace_dict)\n    with open(md_file, \"w\") as f:\n        f.write(\"\".join(replaced_content))\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef get_pdf_paths(pdf_root):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pdf_paths(pdf_root):\n    pdf_paths = []\n    for root, _, files in os.walk(pdf_root):\n        for file in files:\n            if file.lower().endswith(\".pdf\"):\n                pdf_paths.append(os.path.join(root, file))\n    return pdf_paths\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    \"\"\"TODO\"\"\"\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef get_pdf_paths_from_notes(md_root, reg):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pdf_paths_from_notes(md_root, reg):\n    md_files = []\n    for root, _, files in os.walk(md_root):\n        for file in files:\n            if file.lower().endswith(\"md\") or file.lower().endswith(\"markdown\"):\n                md_files.append(os.path.join(root, file))\n    pdf_paths_from_notes = []\n    for md_file in md_files:\n        with open(md_file, \"r\") as f:\n            content = f.read()\n        m = reg.findall(content)\n        m = [i.split(\"(\")[-1].split(\")\")[0] for i in m]\n        pdf_paths_from_notes.extend(m)\n    return pdf_paths_from_notes\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    \"\"\"TODO\"\"\"\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    \"\"\"TODO\"\"\"\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pdf_paths_from_notes_dict = {}\n    if os.path.isdir(md_root):\n        md_files = []\n        for root, _, files in os.walk(md_root):\n            for file in files:\n                if file.lower().endswith(\"md\") or file.lower().endswith(\"markdown\"):\n                    md_files.append(os.path.join(root, file))\n        for md_file in md_files:\n            with open(md_file, \"r\") as f:\n                content = f.read()\n            m = reg.findall(content)\n            m = [i.split(\"(\")[-1].split(\")\")[0] for i in m]\n            pdf_paths_from_notes_dict[md_file] = m\n    else:\n        with open(md_root, \"r\") as f:\n            content = f.read()\n        m = reg.findall(content)\n        m = [i.split(\"(\")[-1].split(\")\")[0] for i in m]\n        pdf_paths_from_notes_dict[md_root] = m\n    return pdf_paths_from_notes_dict\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    \"\"\"TODO\"\"\"\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    pass\n```\n\n---\nFunction Complement\n---\ndef classify_identifier(identifier):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    if identifier.endswith(\"}}\"):\n        return True\n    else:\n        return False\n```"
    },
    {
        "readme": "# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**",
        "repo_sketch": ".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py",
        "relevant_file_paths": [],
        "relevant_file_sketches": "---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    \"\"\"TODO\"\"\"\n```",
        "current_file_path": "easy_literature/utils.py",
        "instruction": "Below is a detailed README.md of repository, repository sketch, as well as some relevant file sketches. Please fill the function body for the given function header.\n\n---\nREADME.md\n---\n# EasyLiterature\n**EasyLiterature** is a Python-based command line tool for automatic literature management. Welcome star or contribute!\n\nSimply list the paper titles (or ids) you want to read in a markdown file and it will automatically `collect and refine its information in the markdown file`, `download the pdf to your local machine`, and `link the pdf to your paper in the markdown file`. You can forever keep your notes within the pdfs and mds on your local machine or cloud driver.\n\nInspired by [Mu Li](https://www.bilibili.com/video/BV1nA41157y4), adapted from [autoLiterature](https://github.com/wilmerwang/autoLiterature). \nCompared to autoLiterature, **EasyLiterature** is much easier to use and supports a wider range of features, such as `title-based paper match`, `paper search and download on Google Scholar and DBLP` (the two main sites for scholars), `citation statistics`, `mannual information update assitant`, etc. **EasyLiterature covers almost all papers thanks to the support of Google Scholar and DBLP!**\n\n---\nRepository Sketch\n---\nHere is a practicable repository sketch.\n\n```\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 easy_literature\n    \u251c\u2500\u2500 DBLP.py # from . import dblp_source as dblp;\n    \u251c\u2500\u2500 GoogleScholar.py\n    \u251c\u2500\u2500 Scholarly.py\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 arxiv.py\n    \u251c\u2500\u2500 crossref.py\n    \u251c\u2500\u2500 dblp_source.py\n    \u251c\u2500\u2500 downloads.py\n    \u251c\u2500\u2500 easyliter.py\n    \u251c\u2500\u2500 medbiorxiv.py\n    \u251c\u2500\u2500 pdfs.py\n    \u2514\u2500\u2500 utils.py\n```\n\n---\nCurrent File Sketch/1\n---\nHere is the file sketch of `easy_literature/utils.py`.\n\n```python\nimport logging\nimport os\nimport re\nfrom tqdm import tqdm\nfrom .downloads import classify, get_paper_info_from_paperid, get_paper_pdf_from_paperid\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"utils\")\nlogger.setLevel(logging.INFO)\n\n\nclass patternRecognizer(object):\n    def __init__(self, regular_rule):\n        pass\n\n    def match(self, string):\n        pass\n\n    def findall(self, string):\n        pass\n\n    def multiple_replace(self, content, **replace_dict):\n        pass\n\n\ndef note_modified(pattern_recog, md_file, **replace_dict):\n    pass\n\n\ndef get_pdf_paths(pdf_root):\n    pass\n\n\ndef get_pdf_paths_from_notes(md_root, reg):\n    pass\n\n\ndef get_pdf_paths_from_notes_dict(md_root, reg):\n    pass\n\n\ndef classify_identifier(identifier):\n    \"\"\"Not need to download PDF file\"\"\"\n    pass\n\n\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    \"\"\"TODO\"\"\"\n```\n\n---\nFunction Complement\n---\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n",
        "input": "",
        "output": "Here is a complete function body.\n\n```python\ndef get_update_content(m, note_file, pdfs_path, proxy, gproxy_mode):\n    replace_dict = dict()\n    for literature in tqdm(m):\n        pdf = classify_identifier(literature)\n        literature_id = literature.split(\"{\")[-1].split(\"}\")[0]\n        bib = get_paper_info_from_paperid(\n            literature_id, proxy=proxy, gproxy_mode=gproxy_mode\n        )\n        if bib:\n            try:\n                pdf_name = bib[\"title\"]\n                pdf_name = re.sub(\"[\\\\n\\\\t\\\\r]\", \"\", pdf_name)\n                pdf_name = re.sub(\" +\", \" \", pdf_name)\n                pdf_name = re.sub(\"[.]\", \"\", pdf_name)\n                pdf_name = \"_\".join(pdf_name.split(\" \")) + \".pdf\"\n                pdf_name = re.sub('[\\\\\\\\/:*?\"<>|]', \"\", pdf_name)\n                pdf_path = os.path.join(pdfs_path, pdf_name)\n                logger.info(f\"The pdf path to be saved: {pdf_path}\")\n                if pdf:\n                    id_type = classify(literature_id)\n                    if id_type == \"title\":\n                        for pattern_str in [\n                            \"10\\\\.(?!1101)[0-9]{4}/\",\n                            \"10\\\\.1101/\",\n                            \"[0-9]{2}[0-1][0-9]\\\\.[0-9]{3,}\",\n                            \".*/[0-9]{2}[0-1][0-9]{4}\",\n                        ]:\n                            res = re.search(pattern_str, bib[\"url\"])\n                            if res:\n                                literature_id = res.group(0)\n                                if bib[\"pdf_link\"] is None:\n                                    bib[\n                                        \"pdf_link\"\n                                    ] = f\"https://arxiv.org/pdf/{literature_id}.pdf\"\n                                logger.info(\n                                    f\"The paper's arxiv url: {bib['url']}; The converted arxiv id: {literature_id}; The pdf link: {bib['pdf_link']}.\"\n                                )\n                        if not os.path.exists(pdf_path):\n                            logger.info(f\"PDF link: {bib['pdf_link']}\")\n                            get_paper_pdf_from_paperid(\n                                literature_id,\n                                pdf_path,\n                                direct_url=bib[\"pdf_link\"],\n                                proxy=proxy,\n                            )\n                            if not os.path.exists(pdf_path):\n                                get_paper_pdf_from_paperid(\n                                    literature_id, pdf_path, proxy=proxy\n                                )\n                    elif not os.path.exists(pdf_path):\n                        logger.info(f\"PDF link: {bib['pdf_link']}\")\n                        get_paper_pdf_from_paperid(\n                            literature_id,\n                            pdf_path,\n                            direct_url=bib[\"pdf_link\"],\n                            proxy=proxy,\n                        )\n                        if not os.path.exists(pdf_path):\n                            get_paper_pdf_from_paperid(\n                                literature_id, pdf_path, proxy=proxy\n                            )\n                if os.path.exists(pdf_path):\n                    replaced_literature = \"- **{}**. {} et.al. **{}**, **{}**, **Number of Citations: **{}, ([pdf]({}))([link]({})).\".format(\n                        bib[\"title\"],\n                        bib[\"author\"].split(\" and \")[0],\n                        bib[\"journal\"],\n                        bib[\"year\"],\n                        bib[\"cited_count\"],\n                        os.path.relpath(pdf_path, note_file).split(\"/\", 1)[-1],\n                        bib[\"url\"],\n                    )\n                else:\n                    logger.info(\n                        \"Can not find a downloading source for literature id {}. You may need to manually download this paper, a template has been generated in the markdown file. Put the pdf file in the folder you specified just now and add its name in the '(pdf)' of your markdown entry.\".format(\n                            literature_id\n                        )\n                    )\n                    replaced_literature = \"- **{}**. {} et.al. **{}**, **{}**, **Number of Citations: **{}, ([pdf]({}))([link]({})).\".format(\n                        bib[\"title\"],\n                        bib[\"author\"].split(\" and \")[0],\n                        bib[\"journal\"],\n                        bib[\"year\"],\n                        bib[\"cited_count\"],\n                        f\"{pdfs_path}/your_pdf_name.pdf\",\n                        bib[\"url\"],\n                    )\n                replace_dict[literature] = replaced_literature\n            except:\n                logger.info(\n                    \"Can not find a downloading source for literature id {}. You may need to manually download this paper, a template has been generated in the markdown file. Put the pdf file in the folder you specified just now and add its name in the '(pdf)' of your markdown entry.\".format(\n                        literature_id\n                    )\n                )\n                replaced_literature = \"- **{}**. {} et.al. **{}**, **{}**, **Number of Citations: **{}, ([pdf]({}))([link]({})).\".format(\n                    bib[\"title\"],\n                    bib[\"author\"].split(\" and \")[0],\n                    bib[\"journal\"],\n                    bib[\"year\"],\n                    bib[\"cited_count\"],\n                    f\"{pdfs_path}/your_pdf_name.pdf\",\n                    bib[\"url\"],\n                )\n                replace_dict[literature] = replaced_literature\n        else:\n            logger.info(\n                \"Can not find the literature {}. You may need to manually download this paper, a template has been generated in the markdown file. Put the pdf file in the folder you specified just now and add its name in the '(pdf)' of your markdown entry.\".format(\n                    literature_id\n                )\n            )\n            replaced_literature = \"- **{}**. ([pdf]({})).\".format(\n                literature_id, f\"{pdfs_path}/your_pdf_name.pdf\"\n            )\n            replace_dict[literature] = replaced_literature\n    return replace_dict\n```"
    }
]